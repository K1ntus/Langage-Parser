%import "abstractTree.*";
%class "ParserExpr";

%embed {: 

static public class MyEvents extends beaver.Parser.Events {
	
	public void syntaxError(Symbol token) {
		System.err.print("Erreur de syntaxe ligne ");
		System.err.println(Symbol.getLine(token.getStart()));
		System.err.print("Token inattendu: ");
		System.err.println(Terminals.NAMES[token.getId()]);
	}
};

:} ;

%init {:
	report = new MyEvents();
:};

%terminals  BEGIN, END, IF, THEN, ELSEIF, OF, NEW, BLOCK, PROCED, SWITCH, CASE, DEFAULT, DO, WHILE, RETURN, READLN, PRINTLN;
%terminals PLUS, MINUS, TIMES, DIVIDED, LPAR, RPAR, EQUAL, COMMA, COLON, SEMICOLON, DBDOT, LBRACKET, RBRACKET, LCURLBR, RCURLBR, CIRCUMFLEX;
%terminals LESS, LESSEQ, GREATER, GRATEREQ, DIFF, TESTEQ, DIFF, TRUE, FALSE, NULL;
%termminals INT, STR, BOOL;
%terminals ID, ARRAY, STRUCT, VAR;
%terminals FUN;

%right UNARY_MINUS, UNARY_NOT, UNARY_POINTER;
%left TIMES, DIVIDED, PLUS, MINUS;

%typeof PI, EXP, FLT = "Double";


%goal Program;

//PROGRAMME

Program =
		type_declaration_part
		variable_declaration_part
		procedure_definition_part
		BEGIN
		statement_list.stm
		END
		;


//DECLARATION DES TYPES NOMMES

Type_declaration_part =
						| ’type ’ Type_declaration_list
						;
					
Type_declaration_list =
						Type_declaration_list  Type_declaration
						| type_declaration
						;
					
Type_declaration =
					IDENTIFIER  EQUAL type  SEMICOLON;
					
					
//DECLARATION DES TYPES					

Type = 
		simple_type
		| named_type
		| index_type
		| array_type
		| pointer_type
		| structure_type
		;
		
Simple_type = 
			| STR
			| INT
			| BOOL
			;
			
Named_type = 
			ID;

Index_type = 
			Enumerated_type
			| Subrange_type
			;

	
Enumerated_type = 
				LPAR Identifier_list RPAR
				;


Subrange_type = 
				| INT DBDOT INT
				| ID DBDOT ID
				;
				
Array_type = 
			ARRAY LBRACKET Range_type RBRACKET OF Type;
			
Range_type =
			Enumerated_type
			| Subrange_type
			| Name_type
			;
			
Pointer_type =
				CIRCUMFLEX Type;
				
Structure_type = 
				STRUCT LCURLBR Feature_list_type RCURLBR;
				
Feature_list_type = 
					Feature_list_type Feature_type
					| Feature_type
					;
					
Feature_type = 
				ID COLON Type SEMICOLON;
				
				
// DECLARATION DES VARIABLES TYPEES				
	
Variable_declaration_part =
						| VAR Variable_declaration_list
						;


Variable_declaration_list =
						Variable_declaration_list  Variable_declaration
						| Variable_declaration;


Variable_declaration =
					Identifier_list  COLON Type SEMICOLON;


Identifier_list =
				Identifier_list  COMMA ID
				| ID
				;
				
				
// DECLARATION ET DEFINITION DES PROCEDURES ET DES FONCTIONS
				
Procedure_definition_part =
							| Procedure_definition_list
							;
							
Procedure_definition_list = 
							Procedure_definition_list Procedure_definition
							| Procedure_definition
							;

Procedure_definition = 
						Procedure_definition_head BLOCK
						| Procedure_definition_head SEMICOLON
						;

Procedure_definition_head = 
							PROCED ID LPAR Argt_part RPAR
							| FUN ID LPAR Argt_part.args RPAR COLON Type
							;
							
Argt_list = 
			Argt_list COLON Argt
			| Argt
			;

Argt = 
		ID COLON Type;
		


// BLOCS
Block = 
		Variable_declaration_part 
		BEGIN
		Statement_list
		END
		;
		
		
// INSTRUCTIONS
		
Statement_list = 
				Statement_list Statement
				| Statement
				;	
				

Statement =
			Simple_statement
			| Structured_statement
			;

Simple_statement = 
				Assignment_statement
				| Procedure_statement
				| New_statement
				| Dispose_statement
				| Println_statement
				| Readln_statement
				| Return_statement
				;

Assignment_statement = 
						Variable_access EQUAL Expression SEMICOLON;


Procedure_statement = 
					Procedure_expression  SEMICOLON;


procedure_expression =
					ID LPAR Expression_part  RPAR;


Expression_part =
				| Expression_list
				;

Expression_lis =
				Expression_list COMMA Expression
				| Expression
				;


New_statement =
				NEW Variable_access SEMICOLON;


Dispose_statement =
					DISPOSE Variable_access SEMICOLON;


Println_statement =
					PRINTLN Expression SEMICOLON;


Readln_statement =
				READLN Expression SEMICOLON;


return_statement =
				RETURN Expression  SEMICOLON;


Structured_statement =
					Block
					| If_statement
					| While_statement
					| Switch_statement
					;


If_statement =
			IF Expression  THEN Statement
			| IF Expression  THEN STatement ELSE Statement
			;


While_statement =
				WHILE Expression DO Statement;

Switch_statement =
				SWITCH Expression BEGIN Case_statement_list END;


Case_statement_list =
					Case_statement_list  Case_statement
					| Case_statement
					;


case_statement =
				 CASE ID COLON Statement
				| DEFAULT COLON Statement
				;


// EXPRESSIONS

variable_access =
				IDENTIFIER
				| Variable_access LBRACKET Expression RBRACKET
				| Expression CIRCUMFLEX
				;
Expression =
			Expression PLUS Expression
			| Expression MINUS Expression
			| MINUS Expression @UNARY_MINUS
			| Expression TIMES Expression
			| Expression DIVIDED expression
			| Expression OR Expression
			| Expression AND Expression
			| NOT Expression
			| Expression LESS Expression
			| Expression LESSEQ Expression
			| Expression GREATER Expression
			| Expression GREATEREQ Expression
			| Expression  TESTEQ Expression
			| Expression  DIFF Expression
			| LPAR Expression RPAR
			| procedure_expression
			| Variable_access
			| Literal
			;

// EXPRESSIONS LITTERALES

Literal =
		INT
		| STR
		| TRUE
		| FALSE
		| NULL
		;













