//////////////////////////////////////////////////
// version 20190401
//////////////////////////////////////////////////

%package "ubordeaux.deptinfo.compilation.project.main";
%class "Parser";

%import "java.util.Iterator";
%import "java.util.List";
%import "java.util.Scanner";
%import "java.util.HashMap";
%import "java.util.Map";
%import "java.util.Stack";
%import "ubordeaux.deptinfo.compilation.project.node.*";
%import "ubordeaux.deptinfo.compilation.project.type.*";

%import "fr.groupname.compilator.environment.*";
%import "fr.groupname.compilator.special.*";



%embed {: 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;
	
:};

%init {: 
	report = new Events();
:};

// KEYWORDS
%terminals TOKEN_TYPE, TOKEN_STRING, TOKEN_INTEGER, TOKEN_BOOLEAN, TOKEN_ARRAY, TOKEN_OF, TOKEN_STRUCT;	//OK
%terminals TOKEN_VAR, TOKEN_PROCEDURE, TOKEN_FUNCTION, TOKEN_BEGIN, TOKEN_END, TOKEN_NEW, TOKEN_DISPOSE;	//OK

%terminals TOKEN_PRINTLN, TOKEN_READLN, TOKEN_RETURN, TOKEN_IF, TOKEN_THEN, TOKEN_ELSE, TOKEN_WHILE, TOKEN_DO;	//OK
%terminals TOKEN_SWITCH, TOKEN_CASE, TOKEN_DEFAULT;	//OK

// PONCTS
%terminals TOKEN_SEMIC, TOKEN_DOTDOT, TOKEN_COLON, TOKEN_COMMA; //OK
%terminals TOKEN_LPAR, TOKEN_RPAR, TOKEN_LBRACKET, TOKEN_RBRACKET, TOKEN_LBRACE, TOKEN_RBRACE;	//OK

// OPERATORS
%terminals TOKEN_AFF, TOKEN_CIRC;
%terminals TOKEN_PLUS, TOKEN_MINUS, TOKEN_TIMES, TOKEN_DIV;	//OK
%terminals TOKEN_AND, TOKEN_OR, TOKEN_NOT;	//OK
%terminals TOKEN_LT, TOKEN_LE, TOKEN_GT, TOKEN_GE, TOKEN_EQ, TOKEN_NE;	//OK

// LITERALS
%terminals TOKEN_IDENTIFIER, TOKEN_LIT_INTEGER, TOKEN_LIT_STRING, TOKEN_TRUE, TOKEN_FALSE, TOKEN_NULL; //OK


//PRIOTITIES
%right TOKEN_CIRC, TOKEN_NOT;
%left TOKEN_AND, TOKEN_AFF, TOKEN_OR;
%left TOKEN_PLUS, TOKEN_MINUS, TOKEN_TIMES, TOKEN_DIV;
%left TOKEN_LT, TOKEN_LE, TOKEN_GT, TOKEN_GE, TOKEN_EQ, TOKEN_NE;

%left TOKEN_ELSE, TOKEN_IF;

/***
* A completer
***/

%goal program;

/***
* Semantique A completer
*
* Quelques astuces:
*
* a) ne mettez jamais de lettres accentuees, Beaver ne fonctionnerait pas
*
* b) quand vous souhaitez mettre du code avant la fin de la regle, 
*     X= A {: je voudrais mettre du code ici :} B {: pour l'exploiter ici :}
* utilisez une rege vide comme ceci:
*
*     X= A empty_X B {: pour l'exploiter ici  :} ;
*     empty_X= {: je voudrais mettre du code ici :};
*
* c) pour implementer une liste, faites comme ceci:
* xxx_list=
*	xxx_list.list xxx.elt {: list.add(elt); return list; :}
*	| xxx.elt {: MyList list = new MyList(); list.add(elt); return list; :}
*	;
*	
*
***/
%typeof TOKEN_LIT_INTEGER = "Integer";
%typeof TOKEN_LIT_STRING, TOKEN_IDENTIFIER = "String";
%typeof println_statement = "void";

%typeof type = "Type";
%typeof feature_type = "TypeFeature";
%typeof feature_list_type = "TypeFeatureList";

%typeof statement = "Node";
%typeof statement_list, expression_list = "NodeList";
%typeof case_statement_list = "NodeCaseList";
%typeof identifier_list = "IdentifierList";

%typeof variable_access, expression = "NodeExp";
%typeof literal  = "NodeLiteral";
%typeof case_statement = "NodeCase";


//%typeof pop_stackenv, push_stackenv = "Void";

program=
	type_declaration_part			//Type env
	variable_declaration_part 		//Type var
	procedure_definition_part		//Type procedure
	TOKEN_BEGIN	push_stackenv							//On empile stackenv
	statement_list.l 									//Inserer variable dans env
	TOKEN_END	pop_stackenv {: return _symbol_l; :}	//On depile stackenv
	;
	
type_declaration_part= 
	/* empty */	
	| TOKEN_TYPE type_declaration_list
	;
	
type_declaration_list=
	type_declaration_list type_declaration
	| type_declaration
	;
	
type_declaration=
	TOKEN_IDENTIFIER.name TOKEN_AFF type.t TOKEN_SEMIC //{: typeEnvironment.putVariable(name, t); return new NodeId(name, t);:}
	;
	
type=
	simple_type			//OK
	| named_type		//OK
	| index_type	
	| array_type		
	| pointer_type		//OK
	| structure_type 	//OK
	;
	
//OK
simple_type=
	TOKEN_STRING		{: return new TypeString();		:}
	| TOKEN_INTEGER		{: return new TypeInt();		:}
	| TOKEN_BOOLEAN		{: return new TypeBoolean();	:}
	;
	
named_type=
	TOKEN_IDENTIFIER.r /*empty*/	{: return new TypeNamed(r);	:}
	;
	
index_type=
	enumerated_type.enum
	| subrange_type.subr
	;
	
enumerated_type=
	TOKEN_LPAR identifier_list.list TOKEN_RPAR 
	;
	
subrange_type= 
	TOKEN_LIT_INTEGER TOKEN_DOTDOT TOKEN_LIT_INTEGER//	{: return new TypeEnumRange(new TypeItemEnum(t1, t1.toString()), new TypeItemEnum(t2, t2.toString())); :}
	| TOKEN_IDENTIFIER TOKEN_DOTDOT TOKEN_IDENTIFIER
	;
	
array_type=
	TOKEN_ARRAY TOKEN_LBRACKET range_type.range TOKEN_RBRACKET TOKEN_OF type.t
	;
	
range_type=
	enumerated_type	
	| subrange_type	
	| named_type	//OK
	;
	
pointer_type=
	TOKEN_CIRC type.t	{: return new TypePointer(t);	:}
	;
	
structure_type=
	TOKEN_STRUCT TOKEN_LBRACE feature_list_type.list TOKEN_RBRACE	{:	return new TypeStruct(list); :}
	;
	
	
feature_list_type=
	feature_list_type.list feature_type.elem	{: list.add(elem); return list; :}
	| feature_type.elem							{: TypeFeatureList list = new TypeFeatureList(elem); return list; :}
	;
	
feature_type=
	TOKEN_IDENTIFIER.id TOKEN_COLON type.t TOKEN_SEMIC	{: return new TypeFeature(id, t); :}
	;
	
	
//Partie avant le begin ou on declare les variables du prgm
variable_declaration_part= 
	/* empty */ 
	| TOKEN_VAR variable_declaration_list 
	;
	
variable_declaration_list=
	variable_declaration_list variable_declaration	//handle la recurrence
	| variable_declaration						
	;
	
variable_declaration=
	identifier_list.id_list TOKEN_COLON type.t TOKEN_SEMIC 	
															{:
																for(String str : id_list){
																	stackEnvironment.add_node_to_latest_portability(new NodeId(str, t), new NodeLiteral(t, 0));
																}
																
																return _symbol_id_list;
															:}
	;
	
	
//OK
identifier_list=
	identifier_list.list TOKEN_COMMA TOKEN_IDENTIFIER.id		{: 
																	//System.out.println("New ID to stack: " + id);
																	list.add(id); return list; :}
	| TOKEN_IDENTIFIER.name										{: 
																	//System.out.println("New ID to stack: " + name);
																	return new IdentifierList(name); 
																:}
	;
	
procedure_definition_part=
	| procedure_definition_list
	;
	
procedure_definition_list=
	procedure_definition_list procedure_definition
	| procedure_definition
	;
	
procedure_definition=
	procedure_definition_head block
	| procedure_declaration_head TOKEN_SEMIC
	;

procedure_definition_head=
	procedure_head
	;
	
procedure_declaration_head=
	procedure_head
	;
	
procedure_head=
	TOKEN_PROCEDURE TOKEN_IDENTIFIER TOKEN_LPAR argt_part TOKEN_RPAR 
	| TOKEN_FUNCTION TOKEN_IDENTIFIER TOKEN_LPAR argt_part TOKEN_RPAR TOKEN_COLON type
	;
	
argt_part=
	/* empty */
	| argt_list.a
	;
	
argt_list=
	argt_list TOKEN_COMMA argt
	| argt
	;
	
argt=
	TOKEN_IDENTIFIER TOKEN_COLON type
	;
	
block=
	variable_declaration_part 		//Inserer varaible dans stack environnement
	TOKEN_BEGIN	push_stackenv		//On empile stackenv
	statement_list.list 			
	TOKEN_END	pop_stackenv 	{: return _symbol_list; :}	//On depile stackenv et return
	;
pop_stackenv  =		{:	stackEnvironment.getEnvironment().pop(); return new EmptySymbol();	:}	;

push_stackenv =		{:	stackEnvironment.getEnvironment().push(new HashMap<NodeId, NodeLiteral>()); return new EmptySymbol(); :}	;

statement_list=
	statement_list.root statement.elt	{: root.add(elt); return root; :}
	| statement.elt	{: return new NodeList(elt); :}
	;


statement=
	simple_statement	
	| structured_statement
	;
	
simple_statement=
	assignment_statement	//OK
	| procedure_statement
	| new_statement			//OK
	| dispose_statement		//OK
	| println_statement		//OK
	| readln_statement		//OK
	| return_statement		//OK
	;
	
//OK
assignment_statement=
	variable_access.e1 TOKEN_AFF expression.e2 TOKEN_SEMIC	
															{:  
																System.out.println(e1 + " <- " + e2); 
																//stackEnvironment.add_node_to_latest_portability(e1, e2);
																return new NodeAssign(e1, e2); 
															:}
	;
	
procedure_statement=
	procedure_expression TOKEN_SEMIC
	;
	
	
//NOT FINISHED
//faudrait match si les params sont valides aussi
procedure_expression=
	TOKEN_IDENTIFIER.func_name TOKEN_LPAR expression_part.args TOKEN_RPAR	{: return new NodeCallFct(func_name, new TypeFunct(null, null, null), args); :}	//Remplacer type int par celle se trouvant dans environment avec func_name
	;
	
	
//OK
expression_part=
	/* empty */
	| expression_list
	;
	

//OK	
expression_list=
	expression_list.root TOKEN_COMMA expression.elt	{: root.add(elt); return root; :}
	| expression.expr									{: return new NodeList(expr); :}
	;

//OK	
new_statement=
	TOKEN_NEW variable_access.node TOKEN_SEMIC	{: return new NodeNew(node); :}
	;
	
//OK
dispose_statement=
	TOKEN_DISPOSE variable_access.node TOKEN_SEMIC	{: return new NodeDispose(node); :}
	;
	
//OK
println_statement=
	TOKEN_PRINTLN expression.e TOKEN_SEMIC	
		{: 
			return new NodeCallFct(
				"println", 
				new TypeFunct("println", 
					new TypeTuple(new TypeString()), 
					new TypeVoid()),
				new NodeList(e));
		:}
	;	

//OK	
readln_statement=
	TOKEN_READLN expression.e TOKEN_SEMIC	
		{: 
			return new NodeCallFct(
				"readln", 
				new TypeFunct("readln", 
					new TypeTuple(), 
					e.getType()),
				new NodeList());
		:}
	;

//OK	
return_statement=
	TOKEN_RETURN expression.node TOKEN_SEMIC	{: return new NodeReturn(node); :}
	;
	
structured_statement=
	block.n
	| if_statement		//OK
	| while_statement	//OK
	| switch_statement	//OK
	;

//OK	
if_statement=
	TOKEN_IF expression.e TOKEN_THEN statement.stm	{:	return new NodeIf(e, stm);	:}
	| TOKEN_IF expression.e TOKEN_THEN statement.stm_then TOKEN_ELSE statement.stm_else	{:	return new NodeIf(e, stm_then, stm_else);	:}
	;

//OK	
while_statement=
	TOKEN_WHILE expression.e1 TOKEN_DO statement.stm	{:	return new NodeWhile(e1, stm);	:}
	;

//OK	
switch_statement=
	TOKEN_SWITCH expression.root TOKEN_BEGIN case_statement_list.case_list TOKEN_END	{: return new NodeSwitch(root, new NodeList(case_list));	:}
	;

//OK	
case_statement_list=
	case_statement_list.list case_statement.item	{: list.add(item); return list; :}
	| case_statement.item							{: NodeCaseList list = new NodeCaseList(); list.add(item); return list; :}
	;

//OK	
case_statement=
	TOKEN_CASE TOKEN_IDENTIFIER.name TOKEN_COLON statement.state	{: return new NodeCase(name, state); :}
	| TOKEN_DEFAULT TOKEN_COLON statement.state						{: return new NodeCase("default", state); :}
	;
	
	
//Recup les valeurs stockees dans les environnements (ou pas, à check)
variable_access=
	TOKEN_IDENTIFIER.name		{: return new NodeId(name, new TypeInt());	:}
	| variable_access.var TOKEN_LBRACKET expression.e TOKEN_RBRACKET
	| expression.e TOKEN_CIRC	{: return new NodePtrAccess(e);	:}
	;
	
expression=
	expression.e1 TOKEN_PLUS expression.e2		{: return new NodeOp("plus", e1, e2); :}
	| expression.e1 TOKEN_MINUS expression.e2	{: return new NodeOp("minus", e1, e2); :}
	| expression.e1 TOKEN_TIMES expression.e2	{: return new NodeOp("times", e1, e2); :}
	| expression.e1 TOKEN_DIV expression.e2		{: return new NodeOp("divide", e1, e2); :}
	| TOKEN_MINUS expression.e					{: return new NodeOp("u_minus", e); :}
	| expression.e1 TOKEN_OR expression.e2		{: return new NodeRel("or", e1, e2); :}
	| expression.e1 TOKEN_AND expression.e2		{: return new NodeRel("an", e1, e2); :}
	| TOKEN_NOT expression.e					{: return new NodeRel("no", e, new NodeLiteral(new TypeBoolean(), false)); :}
	| expression.e1 TOKEN_LT expression.e2		{: return new NodeRel("lt", e1, e2); :} 
	| expression.e1 TOKEN_LE expression.e2		{: return new NodeRel("le", e1, e2); :} 
	| expression.e1 TOKEN_GT expression.e2		{: return new NodeRel("gt", e1, e2); :} 
	| expression.e1 TOKEN_GE expression.e2		{: return new NodeRel("ge", e1, e2); :} 	
	| expression.e1 TOKEN_EQ expression.e2		{: return new NodeRel("eq", e1, e2); :} 
	| expression.e1 TOKEN_NE expression.e2		{: return new NodeRel("ne", e1, e2); :} 
	| TOKEN_LPAR expression.e TOKEN_RPAR		{: return e; :}
	| procedure_expression
	| variable_access		//OK
	| literal				//OK
	;
	
literal=
	TOKEN_LIT_INTEGER.e		{: return new NodeLiteral(new TypeInt(), e);			:}
	| TOKEN_LIT_STRING.e	{: return new NodeLiteral(new TypeString(), e);			:}
	| TOKEN_TRUE			{: return new NodeLiteral(new TypeBoolean(), true);		:}
	| TOKEN_FALSE			{: return new NodeLiteral(new TypeBoolean(), false);	:}
	| TOKEN_NULL			{: return new NodeLiteral(new TypeVoid(), null);		:}
	;
