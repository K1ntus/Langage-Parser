package ubordeaux.deptinfo.compilation.project.main;

import java.util.List;
import java.util.Iterator;
import java.util.Map;
import ubordeaux.deptinfo.compilation.project.type.*;
import fr.groupname.compilator.environment.*;
import java.util.Scanner;
import java.util.HashMap;
import beaver.*;
import fr.groupname.compilator.special.*;
import java.util.Stack;
import java.util.ArrayList;
import ubordeaux.deptinfo.compilation.project.node.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjMMbu5KKMFVrUCmgA9egQQ3GkA25HKH3Gm8HT22e6324138O0igiZZ0kA3hWZ275NK5G" +
		"8go2kA8e2YYmk2BZZWZCwwCmue#CwsvtJzUxBg#wtV2$HV9y$J7#dpwrRj#wfwgNwlY#0kn" +
		"AboCBPw8OgjC1Zs0VxeZdsm$x8G2OEm84u20VZ47H7Uvo6OdH4Nvo1Ct4MSb646TWB3s2Hx" +
		"4OsSd0uZi8nE1QjC0MlutnSXFuOY78CGIKc9CYmzq$GlWGhCG9N8KJj1NvjcP66zaWyYjVm" +
		"9ARARcPOZMSuPnTNOX9v2XwFos3Fj5czPdeeVelE71ccJfF0LVhDpwXpH4H7jb2dQU2AI4g" +
		"TiVNIELBNaqETdC1wSbBgZA#Npj6gKqIT7W6TuIbrBgoNJalLwKMTwe3Eg9GwbzTBvpZLAQ" +
		"7ExmCwbwRKMPLK9nTvclKS3C9blgovE0ojKO0Jq0OdevslhuY7tPUBJiZNJ5LuAf2dDccUZ" +
		"HWSoBCMBw0hZey#8xuyvoRDaulpKlGbry#LzvBsNOoRVNr$m1ZcEb5dzZBMOAOl$WBssl7p" +
		"0hDOcbJf7ipnzSNV$NZFIJgFUt6hF9FMY5yzlnpF3DpcVVVGLk$YMxW3qp4Bj#1gJCCrk1R" +
		"NuNf6RJDH$JJgRaQTelPit8KRS2Dkqd6tM#CsSEGyCp8M5Sr$fo$$NFFrtORxS3hceoUZEY" +
		"J9VxyrhfOZ7qoI$oLV$eKcwbJDkPXHXKdolsgDMyAH6vBatsd5vQABVhC#bstojE#TYetCH" +
		"H$LxCttVOylohPBCS14bQBCS8ME6geyJ7cqyaJbtoa$Z6LOZYTO4qncLV2kgGcyAcCZLk0X" +
		"ULt#Z4VmjEp0izZ2FUuvFCyrNe4QhCScR6ODiWulOglPLrx1TXvlO0VUv7DJoBsrCpMAkDg" +
		"krEdEhrbFzE8TwysL5Pjdoa48OTOVJLWHxCMwg2dRUVIM6sy6Tosx5iZYatWeTtTlzKUOB$" +
		"9H2J8K$0JjaxYFbVEQZg1sVa1xObhQLTpjA$azo#0ndD$LB5PSGra1PF4O6vUXuJEDZVIK$" +
		"3CTr0Wwe4f5G0UDeDFChCQlqwmHTFAe4mxeP3I2JZQp3WheL3I2JYPrgW8wJWDrxAoPV1li" +
		"h26jmrfe9MRtvV6m#q9SlQtep#CapLCMq0Xn3$FgfDWpajvyKlSbrm$nMYRhos2jO$TbyXi" +
		"Pkrx7inPoVF4Ts6l7Em6b8KcLHWUkPlpTZ$T4vt4AhrPsMYD#zVoIF6sD9teN1$DvyAgkVl" +
		"n5LC9VIGFuQwUKKQDyKUqO5RMFPatGabN1SGd7UOStCXQLEFyG4vNDDtySd#y9zSW$CAtyZ" +
		"c$#RTBCxwOv$zZRwBq3sRvtAZOo5fLFkxKlohQZKGtboFoycg30L0LUJU1L6MMi2hpPjUPL" +
		"zdPPn#nnOVFMZk6luZAprdmUhUZpzfLMPls3MHDbyilxzjKyYSWtfF50w6nohUVZtqN40SG" +
		"UuclFrn0mzxUaTe2pA#gZpYhprKTe7RcSl8NyC7a7UJTv5#Ef7VgKt8By9VaWylVaOd19v2" +
		"l9JSdC5MQisuby6BaVkIMvb7m2#tF87SXVnFITFFgwC1yi7zSUMamU5scx1OpfGz#aHEkYV" +
		"pfZ5qNiS7$QszK$X#t1RE$GlchwzbFRkyOjrPvCkwrgzzLhlf0eYMc4fpAcAurtDQwv#g#d" +
		"d#jqkcbxDjj3QN3ERgMr9bvVPoqnMUUMGPIeLaUEkvljwdJkeuul8gu8#2xdwN3odSmtXbY" +
		"kSzgiF8tW$GtDiDQrXk0z3aUlqG#SzsKHssrknNt6zh6njfjDd4X4xz54hcs9Vpxk55tVXT" +
		"g#LlawWdDqxsBUJUJfwkVytRbgytg7VxHopIVk9$A9cGJNukvhzIyXbgfz5T6Qc6VFXy$$l" +
		"qcN44VglCwdxsKodn7CIUUwfuANEz1UflnHX9q3bNihw$Lnz3rtjYf$5U5GaVAq28T7AazL" +
		"Ng7yZlA7yNDocyJxmfS6OhBIMvzR46YtiUnsbjtHiZlvnpXjU6f2pABTNcEwH1ZhbRzJVmy" +
		"TawzjlMwiWU5KnC$FgTIuzZpbM#ijJsTzQQp$L2ld9EKROhxGQMnFzuy9Bx3isePhEpM1kU" +
		"WrYJmpISPi2epfQyrbTOBr5LhzEosRUwyxm6hlyO$3stox$YUxFLCsG$zaasoKb#H5sI3hP" +
		"Psy8C$BMbabZyXAMI4r9k8vUOZd1ua7YFa4tt2PHymbxY6uAmft2U5k8NSGjnFt4VUQyRV9" +
		"hPffWSoHXSPQOywhPRRS8hDafjmiJp7gMVfgv4dJLoDF67xSd1ypvqUZCvSjibNdpw#WB5T" +
		"xMTsgbieIjHOH7yj7slf0VfGVv7lvJhwLR#IVyhLy9V#W$o$oT$aITN$o1V6Psf$AdzJwn9" +
		"p$HkoIzutzL$cZzdrephMosDkhv1tYBU9DsLcNSxivlsREhyYhiFxa3V7kpd$bFzh#bza59" +
		"s4YAzGHj4RmqplAmAj5N5PUJaAKM3YJwAyuYoL0FyK0ytyWfmxdCAzNvuqcZpPrgClVZI12" +
		"h8ayEAoQN5Db3gGzadqZoMFPDvPyBjb39UtXH3LtZchMriCODunjhxuwZrn6Bg9s1Vs3uDK" +
		"n8SBXB#88kgP0T#htO7mdyWIEdK3VEEORH#v9xaMSJlGc#X3TwBTHp775rEvBFeFp6yzSu#" +
		"clOhkAyOMq2saNcWer740eYPq8JXqw9y05$mUFDjqu");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};
 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}
		
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");	//String et Type ?
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = type_declaration_part variable_declaration_part procedure_definition_part TOKEN_BEGIN push_stackenv statement_list.l TOKEN_END pop_stackenv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 6];
					final NodeList l = (NodeList) _symbol_l.value;
					 return _symbol_l;
				}
			},
			Action.NONE,  	// [1] type_declaration_part = 
			RETURN2,	// [2] type_declaration_part = TOKEN_TYPE type_declaration_list; returns 'type_declaration_list' although none is marked
			new Action() {	// [3] type_declaration_list = type_declaration_list type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [4] type_declaration_list = type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [5] type_declaration = TOKEN_IDENTIFIER.name TOKEN_AFF type.t TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					
																
																//stackEnvironment.add_node_to_latest_portability(new NodeId(name, t), new NodeLiteral(t, 0));
																return new EmptySymbol();
				}
			},
			Action.RETURN,	// [6] type = simple_type
			Action.RETURN,	// [7] type = named_type
			Action.RETURN,	// [8] type = index_type
			Action.RETURN,	// [9] type = array_type
			Action.RETURN,	// [10] type = pointer_type
			Action.RETURN,	// [11] type = structure_type
			new Action() {	// [12] simple_type = TOKEN_STRING
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeString();
				}
			},
			new Action() {	// [13] simple_type = TOKEN_INTEGER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeInt();
				}
			},
			new Action() {	// [14] simple_type = TOKEN_BOOLEAN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeBoolean();
				}
			},
			new Action() {	// [15] named_type = TOKEN_IDENTIFIER.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_r = _symbols[offset + 1];
					final String r = (String) _symbol_r.value;
					 return new TypeNamed(r);
				}
			},
			Action.RETURN,	// [16] index_type = enumerated_type
			Action.RETURN,	// [17] index_type = subrange_type
			new Action() {	// [18] enumerated_type = TOKEN_LPAR identifier_list.list TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 2];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					 return new TypeEnumRange(new TypeItemEnum(0, list.first()), new TypeItemEnum(0, list.last()));
				}
			},
			new Action() {	// [19] subrange_type = TOKEN_LIT_INTEGER.min TOKEN_DOTDOT TOKEN_LIT_INTEGER.max
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_min = _symbols[offset + 1];
					final Integer min = (Integer) _symbol_min.value;
					final Symbol _symbol_max = _symbols[offset + 3];
					final Integer max = (Integer) _symbol_max.value;
					 return new TypeArrayRange(new TypeInt(min), new TypeInt(max));
				}
			},
			RETURN3,	// [20] subrange_type = TOKEN_IDENTIFIER.id_min TOKEN_DOTDOT TOKEN_IDENTIFIER.id_max; returns 'id_max' although more are marked
			new Action() {	// [21] array_type = TOKEN_ARRAY TOKEN_LBRACKET range_type.range TOKEN_RBRACKET TOKEN_OF type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_range = _symbols[offset + 3];
					final TypeRange range = (TypeRange) _symbol_range.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final Type t = (Type) _symbol_t.value;
					 return new TypeArray(range, t);
				}
			},
			Action.RETURN,	// [22] range_type = enumerated_type
			Action.RETURN,	// [23] range_type = subrange_type
			Action.RETURN,	// [24] range_type = named_type
			new Action() {	// [25] pointer_type = TOKEN_CIRC type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					 return new TypePointer(t);
				}
			},
			new Action() {	// [26] structure_type = TOKEN_STRUCT TOKEN_LBRACE feature_list_type.list TOKEN_RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 3];
					final TypeFeatureList list = (TypeFeatureList) _symbol_list.value;
						return new TypeStruct(list);
				}
			},
			new Action() {	// [27] feature_list_type = feature_list_type.list feature_type.elem
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final TypeFeatureList list = (TypeFeatureList) _symbol_list.value;
					final Symbol _symbol_elem = _symbols[offset + 2];
					final TypeFeature elem = (TypeFeature) _symbol_elem.value;
					 list.add(elem); return list;
				}
			},
			new Action() {	// [28] feature_list_type = feature_type.elem
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_elem = _symbols[offset + 1];
					final TypeFeature elem = (TypeFeature) _symbol_elem.value;
					 TypeFeatureList list = new TypeFeatureList(elem); return list;
				}
			},
			new Action() {	// [29] feature_type = TOKEN_IDENTIFIER.id TOKEN_COLON type.t TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new TypeFeature(id, t);
				}
			},
			Action.NONE,  	// [30] variable_declaration_part = 
			RETURN2,	// [31] variable_declaration_part = TOKEN_VAR variable_declaration_list; returns 'variable_declaration_list' although none is marked
			new Action() {	// [32] variable_declaration_list = variable_declaration_list variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [33] variable_declaration_list = variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [34] variable_declaration = identifier_list.id_list TOKEN_COLON type.t TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id_list = _symbols[offset + 1];
					final IdentifierList id_list = (IdentifierList) _symbol_id_list.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					
																for(String str : id_list){
																	stackEnvironment.add_node_to_latest_portability(str, new NodeLiteral(t, 0));
																}
																
																return _symbol_id_list;
				}
			},
			new Action() {	// [35] identifier_list = identifier_list.list TOKEN_COMMA TOKEN_IDENTIFIER.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					 
																	//System.out.println("New ID to stack: " + id);
																	list.add(id); return list;
				}
			},
			new Action() {	// [36] identifier_list = TOKEN_IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 
																	//System.out.println("New ID to stack: " + name);
																	return new IdentifierList(name);
				}
			},
			Action.NONE,  	// [37] procedure_definition_part = 
			Action.RETURN,	// [38] procedure_definition_part = procedure_definition_list
			new Action() {	// [39] procedure_definition_list = procedure_definition_list procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [40] procedure_definition_list = procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN2,	// [41] procedure_definition = procedure_definition_head block; returns 'block' although none is marked
			RETURN2,	// [42] procedure_definition = procedure_declaration_head TOKEN_SEMIC; returns 'TOKEN_SEMIC' although none is marked
			Action.RETURN,	// [43] procedure_definition_head = procedure_head
			Action.RETURN,	// [44] procedure_declaration_head = procedure_head
			Action.RETURN,	// [45] procedure_head = TOKEN_PROCEDURE.p TOKEN_IDENTIFIER TOKEN_LPAR argt_part TOKEN_RPAR
			new Action() {	// [46] procedure_head = TOKEN_FUNCTION TOKEN_IDENTIFIER.id TOKEN_LPAR argt_part.args TOKEN_RPAR TOKEN_COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_args = _symbols[offset + 4];
					final NodeList args = (NodeList) _symbol_args.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final Type t = (Type) _symbol_t.value;
																													int n =0;
																									TypeTuple tuple = new TypeTuple();
																									/*
																									for(NodeId elt : args){
																										Type tp = elt.getType();
																										tuple.TypeTuple(TypeString, tp);
																										
																									}*/
																									TypeFunct t1 = new TypeFunct(id, tuple, t);
																								
																									return new NodeCallFct(id,t1,args);
				}
			},
			Action.NONE,  	// [47] argt_part = 
			Action.RETURN,	// [48] argt_part = argt_list
			new Action() {	// [49] argt_list = argt_list.l TOKEN_COMMA argt.elem
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final NodeList l = (NodeList) _symbol_l.value;
					final Symbol _symbol_elem = _symbols[offset + 3];
					final NodeId elem = (NodeId) _symbol_elem.value;
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [50] argt_list = argt.elem
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_elem = _symbols[offset + 1];
					final NodeId elem = (NodeId) _symbol_elem.value;
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [51] argt = TOKEN_IDENTIFIER.id TOKEN_COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new NodeId(id, t);
				}
			},
			new Action() {	// [52] block = variable_declaration_part TOKEN_BEGIN push_stackenv statement_list.list TOKEN_END pop_stackenv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 4];
					final NodeList list = (NodeList) _symbol_list.value;
					 return _symbol_list;
				}
			},
			new Action() {	// [53] pop_stackenv = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
						System.out.println("[STACK] Poped one more stack layer"); stackEnvironment.getEnvironment().pop(); return new EmptySymbol();
				}
			},
			new Action() {	// [54] push_stackenv = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
						System.out.println("[STACK] Pushed one more stack layer"); stackEnvironment.getEnvironment().push(new HashMap<String, NodeLiteral>()); return new EmptySymbol();
				}
			},
			new Action() {	// [55] statement_list = statement_list.root statement.elt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_root = _symbols[offset + 1];
					final NodeList root = (NodeList) _symbol_root.value;
					final Symbol _symbol_elt = _symbols[offset + 2];
					final Node elt = (Node) _symbol_elt.value;
					 root.add(elt); return root;
				}
			},
			new Action() {	// [56] statement_list = statement.elt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_elt = _symbols[offset + 1];
					final Node elt = (Node) _symbol_elt.value;
					 return new NodeList(elt);
				}
			},
			Action.RETURN,	// [57] statement = simple_statement
			Action.RETURN,	// [58] statement = structured_statement
			new Action() {	// [59] simple_statement = assignment_statement.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					 System.out.println("[STATE] assignment: "+e); return e;
				}
			},
			Action.RETURN,	// [60] simple_statement = procedure_statement
			Action.RETURN,	// [61] simple_statement = new_statement
			Action.RETURN,	// [62] simple_statement = dispose_statement
			Action.RETURN,	// [63] simple_statement = println_statement
			Action.RETURN,	// [64] simple_statement = readln_statement
			Action.RETURN,	// [65] simple_statement = return_statement
			new Action() {	// [66] assignment_statement = variable_access.e1 TOKEN_AFF expression.e2 TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					  
																//System.out.println(e1 + " <- " + e2); 
																//stackEnvironment.add_node_to_latest_portability(e1, e2);
																return new NodeAssign(e1, e2);
				}
			},
			RETURN2,	// [67] procedure_statement = procedure_expression TOKEN_SEMIC; returns 'TOKEN_SEMIC' although none is marked
			new Action() {	// [68] procedure_expression = TOKEN_IDENTIFIER.func_name TOKEN_LPAR expression_part.args TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func_name = _symbols[offset + 1];
					final String func_name = (String) _symbol_func_name.value;
					final Symbol _symbol_args = _symbols[offset + 3];
					final NodeList args = (NodeList) _symbol_args.value;
					 return new NodeCallFct(func_name, new TypeFunct(func_name, null, null), args);
				}
			},
			Action.NONE,  	// [69] expression_part = 
			Action.RETURN,	// [70] expression_part = expression_list
			new Action() {	// [71] expression_list = expression_list.root TOKEN_COMMA expression.elt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_root = _symbols[offset + 1];
					final NodeList root = (NodeList) _symbol_root.value;
					final Symbol _symbol_elt = _symbols[offset + 3];
					final NodeExp elt = (NodeExp) _symbol_elt.value;
					 root.add(elt); return root;
				}
			},
			new Action() {	// [72] expression_list = expression.expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_expr = _symbols[offset + 1];
					final NodeExp expr = (NodeExp) _symbol_expr.value;
					 return new NodeList(expr);
				}
			},
			new Action() {	// [73] new_statement = TOKEN_NEW variable_access.node TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_node = _symbols[offset + 2];
					final NodeExp node = (NodeExp) _symbol_node.value;
					 return new NodeNew(node);
				}
			},
			new Action() {	// [74] dispose_statement = TOKEN_DISPOSE variable_access.node TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_node = _symbols[offset + 2];
					final NodeExp node = (NodeExp) _symbol_node.value;
					 return new NodeDispose(node);
				}
			},
			new Action() {	// [75] println_statement = TOKEN_PRINTLN expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
			return new NodeCallFct(
				"println", 					//fonction name
				new TypeFunct("println", 	//Un string jsp a quoi il sert
					new TypeTuple(), 	//Type parametres
					new TypeVoid()),	//Return type
				new NodeList(e));		//Args
				}
			},
			new Action() {	// [76] readln_statement = TOKEN_READLN expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
			return new NodeCallFct(
				"readln", 
				new TypeFunct("readln", 
					new TypeTuple(e.getType()), 
					e.getType()),
				new NodeList());
				}
			},
			new Action() {	// [77] return_statement = TOKEN_RETURN expression.node TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_node = _symbols[offset + 2];
					final NodeExp node = (NodeExp) _symbol_node.value;
					 return new NodeReturn(node);
				}
			},
			Action.RETURN,	// [78] structured_statement = block
			Action.RETURN,	// [79] structured_statement = if_statement
			Action.RETURN,	// [80] structured_statement = while_statement
			Action.RETURN,	// [81] structured_statement = switch_statement
			new Action() {	// [82] if_statement = TOKEN_IF expression.e TOKEN_THEN statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
						return new NodeIf(e, stm);
				}
			},
			new Action() {	// [83] if_statement = TOKEN_IF expression.e TOKEN_THEN statement.stm_then TOKEN_ELSE statement.stm_else
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm_then = _symbols[offset + 4];
					final Node stm_then = (Node) _symbol_stm_then.value;
					final Symbol _symbol_stm_else = _symbols[offset + 6];
					final Node stm_else = (Node) _symbol_stm_else.value;
						return new NodeIf(e, stm_then, stm_else);
				}
			},
			new Action() {	// [84] while_statement = TOKEN_WHILE expression.e1 TOKEN_DO statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 2];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
						return new NodeWhile(e1, stm);
				}
			},
			new Action() {	// [85] switch_statement = TOKEN_SWITCH expression.root TOKEN_BEGIN case_statement_list.case_list TOKEN_END
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_root = _symbols[offset + 2];
					final NodeExp root = (NodeExp) _symbol_root.value;
					final Symbol _symbol_case_list = _symbols[offset + 4];
					final NodeCaseList case_list = (NodeCaseList) _symbol_case_list.value;
					 return new NodeSwitch(root, case_list);
				}
			},
			new Action() {	// [86] case_statement_list = case_statement_list.list case_statement.item
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeCaseList list = (NodeCaseList) _symbol_list.value;
					final Symbol _symbol_item = _symbols[offset + 2];
					final NodeCase item = (NodeCase) _symbol_item.value;
					 list.add(item); return list;
				}
			},
			new Action() {	// [87] case_statement_list = case_statement.item
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_item = _symbols[offset + 1];
					final NodeCase item = (NodeCase) _symbol_item.value;
					 NodeCaseList list = new NodeCaseList(); list.add(item); return list;
				}
			},
			new Action() {	// [88] case_statement = TOKEN_CASE TOKEN_IDENTIFIER.name TOKEN_COLON statement.state
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 2];
					final String name = (String) _symbol_name.value;
					final Symbol _symbol_state = _symbols[offset + 4];
					final Node state = (Node) _symbol_state.value;
					 return new NodeCase(name, state);
				}
			},
			new Action() {	// [89] case_statement = TOKEN_DEFAULT TOKEN_COLON statement.state
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_state = _symbols[offset + 3];
					final Node state = (Node) _symbol_state.value;
					 return new NodeCase("default", state);
				}
			},
			new Action() {	// [90] variable_access = TOKEN_IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
						
										try{
											System.out.println("[VARIABLE]" + name +" found.");
											return stackEnvironment.get_node_reachable(name);  
										} catch (NoSuchFieldException e) {
											System.out.println(e);
											return new NodeLiteral(null, -1);
										}
				}
			},
			new Action() {	// [91] variable_access = variable_access.var TOKEN_LBRACKET expression.e TOKEN_RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_var = _symbols[offset + 1];
					final NodeExp var = (NodeExp) _symbol_var.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeArrayAccess(var, e);
				}
			},
			new Action() {	// [92] variable_access = expression.e TOKEN_CIRC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodePtrAccess(e);
				}
			},
			new Action() {	// [93] expression = expression.e1 TOKEN_PLUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("plus", e1, e2);
				}
			},
			new Action() {	// [94] expression = expression.e1 TOKEN_MINUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("minus", e1, e2);
				}
			},
			new Action() {	// [95] expression = expression.e1 TOKEN_TIMES expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("times", e1, e2);
				}
			},
			new Action() {	// [96] expression = expression.e1 TOKEN_DIV expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("divide", e1, e2);
				}
			},
			new Action() {	// [97] expression = TOKEN_MINUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeOp("u_minus", e);
				}
			},
			new Action() {	// [98] expression = expression.e1 TOKEN_OR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("or", e1, e2);
				}
			},
			new Action() {	// [99] expression = expression.e1 TOKEN_AND expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("an", e1, e2);
				}
			},
			new Action() {	// [100] expression = TOKEN_NOT expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeRel("no", e, new NodeLiteral(new TypeBoolean(), false));
				}
			},
			new Action() {	// [101] expression = expression.e1 TOKEN_LT expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("lt", e1, e2);
				}
			},
			new Action() {	// [102] expression = expression.e1 TOKEN_LE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("le", e1, e2);
				}
			},
			new Action() {	// [103] expression = expression.e1 TOKEN_GT expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("gt", e1, e2);
				}
			},
			new Action() {	// [104] expression = expression.e1 TOKEN_GE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("ge", e1, e2);
				}
			},
			new Action() {	// [105] expression = expression.e1 TOKEN_EQ expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("eq", e1, e2);
				}
			},
			new Action() {	// [106] expression = expression.e1 TOKEN_NE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("ne", e1, e2);
				}
			},
			new Action() {	// [107] expression = TOKEN_LPAR expression.e TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return e;
				}
			},
			Action.RETURN,	// [108] expression = procedure_expression
			Action.RETURN,	// [109] expression = variable_access
			Action.RETURN,	// [110] expression = literal
			new Action() {	// [111] literal = TOKEN_LIT_INTEGER.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Integer e = (Integer) _symbol_e.value;
					 return new NodeLiteral(new TypeInt(), e);
				}
			},
			new Action() {	// [112] literal = TOKEN_LIT_STRING.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final String e = (String) _symbol_e.value;
					 return new NodeLiteral(new TypeString(), e);
				}
			},
			new Action() {	// [113] literal = TOKEN_TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), true);
				}
			},
			new Action() {	// [114] literal = TOKEN_FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), false);
				}
			},
			new Action() {	// [115] literal = TOKEN_NULL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeVoid(), null);
				}
			}
		};

 
	report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
