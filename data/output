


*************************************************
*** Fichier data/progr1.lea
[INFO] $$  : multiple line comment.
[INFO] $$$ : documentation comment.


** Enregistre fct:sum
** SEQ(Label(L0),MOVE(EXP(t0),BINOP(1,NAME(i),NAME(j))))
funct; SEQ(Label(L1),MOVE(EXP(t1),BINOP(1,NAME(i),NAME(j))))

Programme y86 :

.pos 0
	irmovl stack,%esp
	jmp main

main:
	halt

mult:
	mrmovl 4(%esp), %ecx
	mrmovl 8(%esp), %edx
	xorl %eax, %eax
multbcl:
	andl %edx, %edx
	je multfin
	addl %ecx, %eax
	isubl 1,%edx
	jmp multbcl
multfin: ret
div:
	popl %eax
	popl %eax

	.align 4
stack:



Intermediate Code:
* MOVE(CONST:100,NAME(a))
* MOVE(BINOP(2,CONST:5,CONST:2),NAME(a))
* CALL(NAME(sum),CONST:3CONST:5)
* MOVE(CALL(NAME(sum),CONST:3CONST:5),NAME(a))
* CALL(NAME(println),NAME(a))
* MOVE(BINOP(-1,NAME(a),CONST:1),NAME(a))
SEQ(Label(L2),SEQ(CJUMP(13,NAME(a),CONST:0,L3,L4),SEQ(Label(L3),SEQ(SEQ(EXP(CALL(NAME(println),NAME(a))),MOVE(BINOP(-1,NAME(a),CONST:1),NAME(a))),SEQ(JUMP(NAME(L2),L2),Label(L4))))))
** SEQ(MOVE(CONST:100,NAME(a)),SEQ(MOVE(BINOP(2,CONST:5,CONST:2),NAME(a)),SEQ(MOVE(CALL(NAME(sum),CONST:3CONST:5),NAME(a)),SEQ(Label(L2),SEQ(CJUMP(13,NAME(a),CONST:0,L3,L4),SEQ(Label(L3),SEQ(SEQ(EXP(CALL(NAME(println),NAME(a))),MOVE(BINOP(-1,NAME(a),CONST:1),NAME(a))),SEQ(JUMP(NAME(L2),L2),Label(L4)))))))))
* MOVE(CONST:100,NAME(a))
* MOVE(BINOP(2,CONST:5,CONST:2),NAME(a))
* CALL(NAME(sum),CONST:3CONST:5)
* MOVE(CALL(NAME(sum),CONST:3CONST:5),NAME(a))
* CALL(NAME(println),NAME(a))
* MOVE(BINOP(-1,NAME(a),CONST:1),NAME(a))
SEQ(Label(L5),SEQ(CJUMP(13,NAME(a),CONST:0,L6,L7),SEQ(Label(L6),SEQ(SEQ(EXP(CALL(NAME(println),NAME(a))),MOVE(BINOP(-1,NAME(a),CONST:1),NAME(a))),SEQ(JUMP(NAME(L5),L5),Label(L7))))))
a = 100
a = #t1 = 5 2 2
a = code call to: NAME(sum), args: 
label: L6
label: L7
a = #t2 = a -1 1

Programme y86 :

.pos 0
	irmovl stack,%esp
	jmp main

main:
	irmovl 100,%eax
	rmmovl %eax,la
	irmovl #t1 = 5 2 2,%eax
	rmmovl %eax,la
	irmovl code call to: NAME(sum), args: ,%eax
	rmmovl %eax,la
L6:
L7:
	irmovl #t2 = a -1 1,%eax
	rmmovl %eax,la
	halt

mult:
	mrmovl 4(%esp), %ecx
	mrmovl 8(%esp), %edx
	xorl %eax, %eax
multbcl:
	andl %edx, %edx
	je multfin
	addl %ecx, %eax
	isubl 1,%edx
	jmp multbcl
multfin: ret
div:
	popl %eax
	popl %eax

	.align 4
la:	.long 0
stack:
--- CheckType NodeList
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeOp
- NodeOp well typed
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeCallFct
--- CheckType NodeLiteral
--- CheckType NodeLiteral
- NodeCallFct well typed
- Assign well typed
--- CheckType NodeWhile
- NodeList well typed
*** Typage correct



*************************************************
*** Fichier data/progr2.lea
[INFO] $$  : multiple line comment.
[INFO] $$$ : documentation comment.


//
// gestion des variables statiques
//
// 0x4995F6B5



Intermediate Code:
* MOVE(CONST:1234564789,NAME(x))
* MOVE(CONST:2147483647,NAME(y))
* MOVE(CONST:1,NAME(b))
* MOVE(CONST:-1,NAME(c))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:1)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:2)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:3)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:10)))
* CALL(NAME(println),NAME(x))
* CALL(NAME(println),NAME(y))
* CALL(NAME(println),NAME(b))
* CALL(NAME(println),NAME(c))
* CALL(NAME(println),MEM(BINOP(0,NAME(d),CONST:2)))
** SEQ(MOVE(CONST:1234564789,NAME(x)),SEQ(MOVE(CONST:2147483647,NAME(y)),SEQ(MOVE(CONST:1,NAME(b)),SEQ(MOVE(CONST:-1,NAME(c)),SEQ(MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:1))),SEQ(MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:2))),SEQ(MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:3))),SEQ(MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:10))),SEQ(EXP(CALL(NAME(println),NAME(x))),SEQ(EXP(CALL(NAME(println),NAME(y))),SEQ(EXP(CALL(NAME(println),NAME(b))),SEQ(EXP(CALL(NAME(println),NAME(c))),EXP(CALL(NAME(println),MEM(BINOP(0,NAME(d),CONST:2))))))))))))))))
* MOVE(CONST:1234564789,NAME(x))
* MOVE(CONST:2147483647,NAME(y))
* MOVE(CONST:1,NAME(b))
* MOVE(CONST:-1,NAME(c))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:1)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:2)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:3)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:10)))
* CALL(NAME(println),NAME(x))
* CALL(NAME(println),NAME(y))
* CALL(NAME(println),NAME(b))
* CALL(NAME(println),NAME(c))
* CALL(NAME(println),MEM(BINOP(0,NAME(d),CONST:2)))
a = 100
a = #t1 = 5 2 2
a = code call to: NAME(sum), args: 
label: L6
label: L7
a = #t2 = a -1 1
x = 1234564789
y = 2147483647
b = 1
c = -1

Programme y86 :

.pos 0
	irmovl stack,%esp
	jmp main

main:
	pushl ebx
	pushl esi
	irmovl 100,%eax
	rmmovl %eax,la
	irmovl #t1 = 5 2 2,%eax
	rmmovl %eax,la
	irmovl code call to: NAME(sum), args: ,%eax
	rmmovl %eax,la
L6:
L7:
	irmovl #t2 = a -1 1,%eax
	rmmovl %eax,la
	irmovl 1234564789,%ecx
	rmmovl %ecx,lx
	irmovl 2147483647,%edx
	rmmovl %edx,ly
	irmovl 1,%ebx
	rmmovl %ebx,lb
	irmovl -1,%esi
	rmmovl %esi,lc
	popl esi
	popl ebx
	halt

mult:
	mrmovl 4(%esp), %ecx
	mrmovl 8(%esp), %edx
	xorl %eax, %eax
multbcl:
	andl %edx, %edx
	je multfin
	addl %ecx, %eax
	isubl 1,%edx
	jmp multbcl
multfin: ret
div:
	popl %eax
	popl %eax

	.align 4
la:	.long 0
lb:	.long 0
lc:	.long 0
lx:	.long 0
ly:	.long 0
stack:
--- CheckType NodeList
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
- ArrayAccess well typed
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
- ArrayAccess well typed
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
- ArrayAccess well typed
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
- ArrayAccess well typed
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeArrayAccess
- ArrayAccess well typed
- NodeCallFct well typed
- NodeList well typed
*** Typage correct



*************************************************
*** Fichier data/progr3.lea
[INFO] $$  : multiple line comment.
[INFO] $$$ : documentation comment.


// gestion des variables statiques
// gestion du tas et des pointeurs
// 
// 0x4995F6B5
// 0x41
// resize the heap
// heap memory error



Intermediate Code:
* MOVE(CONST:1234564789,NAME(x))
* MOVE(CONST:2147483647,NAME(y))
* MOVE(CONST:1,NAME(b))
* MOVE(CONST:-1,NAME(c))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:1)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:2)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:3)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:10)))
* CALL(NAME(println),NAME(x))
* CALL(NAME(println),NAME(y))
* CALL(NAME(println),NAME(b))
* CALL(NAME(println),NAME(c))
* CALL(NAME(println),MEM(BINOP(0,NAME(d),CONST:2)))
* MOVE(CONST:-1,MEM(NAME(q)))
* CALL(NAME(println),MEM(NAME(q)))
* CALL(NAME(println),NAME(p))
* CALL(NAME(println),NAME(p))
* MOVE(NAME(x),MEM(NAME(p)))
* CALL(NAME(println),MEM(NAME(p)))
* MOVE(CONST:65536,MEM(NAME(r)))
* CALL(NAME(println),MEM(NAME(r)))
* CALL(NAME(println),NAME(p))
* CALL(NAME(println),MEM(NAME(p)))
** SEQ(MOVE(CONST:1234564789,NAME(x)),SEQ(MOVE(CONST:2147483647,NAME(y)),SEQ(MOVE(CONST:1,NAME(b)),SEQ(MOVE(CONST:-1,NAME(c)),SEQ(MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:1))),SEQ(MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:2))),SEQ(MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:3))),SEQ(MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:10))),SEQ(EXP(CALL(NAME(println),NAME(x))),SEQ(EXP(CALL(NAME(println),NAME(y))),SEQ(EXP(CALL(NAME(println),NAME(b))),SEQ(EXP(CALL(NAME(println),NAME(c))),SEQ(EXP(CALL(NAME(println),MEM(BINOP(0,NAME(d),CONST:2)))),SEQ(MOVE(MEM(NAME(q)),NAME(null)),SEQ(MOVE(CONST:-1,MEM(NAME(q))),SEQ(EXP(CALL(NAME(println),MEM(NAME(q)))),SEQ(EXP(CALL(NAME(println),NAME(p))),SEQ(MOVE(MEM(NAME(p)),NAME(null)),SEQ(EXP(CALL(NAME(println),NAME(p))),SEQ(MOVE(NAME(x),MEM(NAME(p))),SEQ(EXP(CALL(NAME(println),MEM(NAME(p)))),SEQ(MOVE(MEM(NAME(r)),NAME(null)),SEQ(MOVE(CONST:65536,MEM(NAME(r))),SEQ(EXP(CALL(NAME(println),MEM(NAME(r)))),SEQ(MOVE(MEM(NAME(p)),NAME(null)),SEQ(EXP(CALL(NAME(println),NAME(p))),EXP(CALL(NAME(println),MEM(NAME(p))))))))))))))))))))))))))))))
* MOVE(CONST:1234564789,NAME(x))
* MOVE(CONST:2147483647,NAME(y))
* MOVE(CONST:1,NAME(b))
* MOVE(CONST:-1,NAME(c))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:1)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:2)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:3)))
* MOVE(CONST:-1,MEM(BINOP(0,NAME(d),CONST:10)))
* CALL(NAME(println),NAME(x))
* CALL(NAME(println),NAME(y))
* CALL(NAME(println),NAME(b))
* CALL(NAME(println),NAME(c))
* CALL(NAME(println),MEM(BINOP(0,NAME(d),CONST:2)))
* MOVE(CONST:-1,MEM(NAME(q)))
* CALL(NAME(println),MEM(NAME(q)))
* CALL(NAME(println),NAME(p))
* CALL(NAME(println),NAME(p))
* MOVE(NAME(x),MEM(NAME(p)))
* CALL(NAME(println),MEM(NAME(p)))
* MOVE(CONST:65536,MEM(NAME(r)))
* CALL(NAME(println),MEM(NAME(r)))
* CALL(NAME(println),NAME(p))
* CALL(NAME(println),MEM(NAME(p)))
a = 100
a = #t1 = 5 2 2
a = code call to: NAME(sum), args: 
label: L6
label: L7
a = #t2 = a -1 1
x = 1234564789
y = 2147483647
b = 1
c = -1
x = 1234564789
y = 2147483647
b = 1
c = -1
null = label: sss
null = label: sss
null = label: sss
null = label: sss

Programme y86 :

.pos 0
	irmovl stack,%esp
	jmp main

main:
	pushl ebx
	pushl esi
	pushl edi
	irmovl 100,%eax
	rmmovl %eax,la
	irmovl #t1 = 5 2 2,%eax
	rmmovl %eax,la
	irmovl code call to: NAME(sum), args: ,%eax
	rmmovl %eax,la
L6:
L7:
	irmovl #t2 = a -1 1,%eax
	rmmovl %eax,la
	irmovl 1234564789,%ecx
	rmmovl %ecx,lx
	irmovl 2147483647,%edx
	rmmovl %edx,ly
	irmovl 1,%ebx
	rmmovl %ebx,lb
	irmovl -1,%esi
	rmmovl %esi,lc
	irmovl 1234564789,%ecx
	rmmovl %ecx,lx
	irmovl 2147483647,%edx
	rmmovl %edx,ly
	irmovl 1,%ebx
	rmmovl %ebx,lb
	irmovl -1,%esi
	rmmovl %esi,lc
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	popl edi
	popl esi
	popl ebx
	halt

mult:
	mrmovl 4(%esp), %ecx
	mrmovl 8(%esp), %edx
	xorl %eax, %eax
multbcl:
	andl %edx, %edx
	je multfin
	addl %ecx, %eax
	isubl 1,%edx
	jmp multbcl
multfin: ret
div:
	popl %eax
	popl %eax

	.align 4
la:	.long 0
lb:	.long 0
lnull:	.long 0
lc:	.long 0
lx:	.long 0
ly:	.long 0
stack:
--- CheckType NodeList
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
- ArrayAccess well typed
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
- ArrayAccess well typed
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
- ArrayAccess well typed
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeAssign
--- CheckType NodeArrayAccess
- ArrayAccess well typed
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeArrayAccess
- ArrayAccess well typed
- NodeCallFct well typed
--- CheckType NodeNew
--- CheckType NodeAssign
--- CheckType NodePtrAccess
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeCallFct
--- CheckType NodePtrAccess
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeNew
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeAssign
--- CheckType NodePtrAccess
--- CheckType NodeId
- Assign well typed
--- CheckType NodeCallFct
--- CheckType NodePtrAccess
- NodeCallFct well typed
--- CheckType NodeNew
--- CheckType NodeAssign
--- CheckType NodePtrAccess
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeCallFct
--- CheckType NodePtrAccess
- NodeCallFct well typed
--- CheckType NodeDispose
--- CheckType NodeCallFct
--- CheckType NodeId
- NodeCallFct well typed
--- CheckType NodeCallFct
--- CheckType NodePtrAccess
- NodeCallFct well typed
- NodeList well typed
*** Typage correct



*************************************************
*** Fichier data/progr4.lea
[INFO] $$  : multiple line comment.
[INFO] $$$ : documentation comment.


//
// Structure de contr√¥le
//
//



Intermediate Code:
* MOVE(CONST:1,NAME(x))
* CALL(NAME(println),NAME(x))
* MOVE(CONST:1,NAME(y))
* CALL(NAME(println),BINOP(-1,BINOP(2,CONST:1000,CONST:-1),NAME(y)))
* MOVE(BINOP(1,NAME(y),CONST:1),NAME(y))
SEQ(Label(L13),SEQ(CJUMP(11,NAME(y),CONST:5,L14,L15),SEQ(Label(L14),SEQ(SEQ(EXP(CALL(NAME(println),BINOP(-1,BINOP(2,CONST:1000,CONST:-1),NAME(y)))),MOVE(BINOP(1,NAME(y),CONST:1),NAME(y))),SEQ(JUMP(NAME(L13),L13),Label(L15))))))
* CALL(NAME(println),CONST:-1)
* MOVE(BINOP(1,NAME(x),CONST:1),NAME(x))
SEQ(Label(L8),SEQ(CJUMP(11,NAME(x),CONST:10,L9,L10),SEQ(Label(L9),SEQ(SEQ(EXP(CALL(NAME(println),NAME(x))),SEQ(SEQ(CJUMP(14,NAME(x),NAME(x),L11,L12),SEQ(Label(L11),SEQ(SEQ(MOVE(CONST:1,NAME(y)),SEQ(Label(L13),SEQ(CJUMP(11,NAME(y),CONST:5,L14,L15),SEQ(Label(L14),SEQ(SEQ(EXP(CALL(NAME(println),BINOP(-1,BINOP(2,CONST:1000,CONST:-1),NAME(y)))),MOVE(BINOP(1,NAME(y),CONST:1),NAME(y))),SEQ(JUMP(NAME(L13),L13),Label(L15))))))),SEQ(Label(L12),EXP(CALL(NAME(println),CONST:-1)))))),MOVE(BINOP(1,NAME(x),CONST:1),NAME(x)))),SEQ(JUMP(NAME(L8),L8),Label(L10))))))
** SEQ(MOVE(CONST:1,NAME(x)),SEQ(Label(L8),SEQ(CJUMP(11,NAME(x),CONST:10,L9,L10),SEQ(Label(L9),SEQ(SEQ(EXP(CALL(NAME(println),NAME(x))),SEQ(SEQ(CJUMP(14,NAME(x),NAME(x),L11,L12),SEQ(Label(L11),SEQ(SEQ(MOVE(CONST:1,NAME(y)),SEQ(Label(L13),SEQ(CJUMP(11,NAME(y),CONST:5,L14,L15),SEQ(Label(L14),SEQ(SEQ(EXP(CALL(NAME(println),BINOP(-1,BINOP(2,CONST:1000,CONST:-1),NAME(y)))),MOVE(BINOP(1,NAME(y),CONST:1),NAME(y))),SEQ(JUMP(NAME(L13),L13),Label(L15))))))),SEQ(Label(L12),EXP(CALL(NAME(println),CONST:-1)))))),MOVE(BINOP(1,NAME(x),CONST:1),NAME(x)))),SEQ(JUMP(NAME(L8),L8),Label(L10)))))))
* MOVE(CONST:1,NAME(x))
* CALL(NAME(println),NAME(x))
* MOVE(CONST:1,NAME(y))
* CALL(NAME(println),BINOP(-1,BINOP(2,CONST:1000,CONST:-1),NAME(y)))
* MOVE(BINOP(1,NAME(y),CONST:1),NAME(y))
SEQ(Label(L21),SEQ(CJUMP(11,NAME(y),CONST:5,L22,L23),SEQ(Label(L22),SEQ(SEQ(EXP(CALL(NAME(println),BINOP(-1,BINOP(2,CONST:1000,CONST:-1),NAME(y)))),MOVE(BINOP(1,NAME(y),CONST:1),NAME(y))),SEQ(JUMP(NAME(L21),L21),Label(L23))))))
* CALL(NAME(println),CONST:-1)
* MOVE(BINOP(1,NAME(x),CONST:1),NAME(x))
SEQ(Label(L16),SEQ(CJUMP(11,NAME(x),CONST:10,L17,L18),SEQ(Label(L17),SEQ(SEQ(EXP(CALL(NAME(println),NAME(x))),SEQ(SEQ(CJUMP(14,NAME(x),NAME(x),L19,L20),SEQ(Label(L19),SEQ(SEQ(MOVE(CONST:1,NAME(y)),SEQ(Label(L21),SEQ(CJUMP(11,NAME(y),CONST:5,L22,L23),SEQ(Label(L22),SEQ(SEQ(EXP(CALL(NAME(println),BINOP(-1,BINOP(2,CONST:1000,CONST:-1),NAME(y)))),MOVE(BINOP(1,NAME(y),CONST:1),NAME(y))),SEQ(JUMP(NAME(L21),L21),Label(L23))))))),SEQ(Label(L20),EXP(CALL(NAME(println),CONST:-1)))))),MOVE(BINOP(1,NAME(x),CONST:1),NAME(x)))),SEQ(JUMP(NAME(L16),L16),Label(L18))))))
a = 100
a = #t1 = 5 2 2
a = code call to: NAME(sum), args: 
label: L6
label: L7
a = #t2 = a -1 1
x = 1234564789
y = 2147483647
b = 1
c = -1
x = 1234564789
y = 2147483647
b = 1
c = -1
null = label: sss
null = label: sss
null = label: sss
null = label: sss
x = 1
label: L17
label: L18
label: L19
label: L20
y = 1
label: L22
label: L23
y = #t3 = y 1 1
x = #t4 = x 1 1

Programme y86 :

.pos 0
	irmovl stack,%esp
	jmp main

main:
	pushl ebx
	pushl esi
	pushl edi
	irmovl 100,%eax
	rmmovl %eax,la
	irmovl #t1 = 5 2 2,%eax
	rmmovl %eax,la
	irmovl code call to: NAME(sum), args: ,%eax
	rmmovl %eax,la
L6:
L7:
	irmovl #t2 = a -1 1,%eax
	rmmovl %eax,la
	irmovl 1234564789,%ecx
	rmmovl %ecx,lx
	irmovl 2147483647,%edx
	rmmovl %edx,ly
	irmovl 1,%ebx
	rmmovl %ebx,lb
	irmovl -1,%esi
	rmmovl %esi,lc
	irmovl 1234564789,%ecx
	rmmovl %ecx,lx
	irmovl 2147483647,%edx
	rmmovl %edx,ly
	irmovl 1,%ebx
	rmmovl %ebx,lb
	irmovl -1,%esi
	rmmovl %esi,lc
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl 1,%ecx
	rmmovl %ecx,lx
L17:
L18:
L19:
L20:
	irmovl 1,%edx
	rmmovl %edx,ly
L22:
L23:
	irmovl #t3 = y 1 1,%edx
	rmmovl %edx,ly
	irmovl #t4 = x 1 1,%ecx
	rmmovl %ecx,lx
	popl edi
	popl esi
	popl ebx
	halt

mult:
	mrmovl 4(%esp), %ecx
	mrmovl 8(%esp), %edx
	xorl %eax, %eax
multbcl:
	andl %edx, %edx
	je multfin
	addl %ecx, %eax
	isubl 1,%edx
	jmp multbcl
multfin: ret
div:
	popl %eax
	popl %eax

	.align 4
la:	.long 0
lb:	.long 0
lnull:	.long 0
lc:	.long 0
lx:	.long 0
ly:	.long 0
stack:
--- CheckType NodeList
--- CheckType NodeAssign
--- CheckType NodeId
--- CheckType NodeLiteral
- Assign well typed
--- CheckType NodeWhile
- NodeList well typed
*** Typage correct



*************************************************
*** Fichier data/progr5.lea
[INFO] $$  : multiple line comment.
[INFO] $$$ : documentation comment.


** Enregistre fct:sum
** SEQ(Label(L24),MOVE(EXP(t2),BINOP(1,NAME(i),NAME(j))))
funct; SEQ(Label(L25),MOVE(EXP(t3),BINOP(1,NAME(i),NAME(j))))
a = 100
a = #t1 = 5 2 2
a = code call to: NAME(sum), args: 
label: L6
label: L7
a = #t2 = a -1 1
x = 1234564789
y = 2147483647
b = 1
c = -1
x = 1234564789
y = 2147483647
b = 1
c = -1
null = label: sss
null = label: sss
null = label: sss
null = label: sss
x = 1
label: L17
label: L18
label: L19
label: L20
y = 1
label: L22
label: L23
y = #t3 = y 1 1
x = #t4 = x 1 1

Programme y86 :

.pos 0
	irmovl stack,%esp
	jmp main

main:
	pushl ebx
	pushl esi
	pushl edi
	irmovl 100,%eax
	rmmovl %eax,la
	irmovl #t1 = 5 2 2,%eax
	rmmovl %eax,la
	irmovl code call to: NAME(sum), args: ,%eax
	rmmovl %eax,la
L6:
L7:
	irmovl #t2 = a -1 1,%eax
	rmmovl %eax,la
	irmovl 1234564789,%ecx
	rmmovl %ecx,lx
	irmovl 2147483647,%edx
	rmmovl %edx,ly
	irmovl 1,%ebx
	rmmovl %ebx,lb
	irmovl -1,%esi
	rmmovl %esi,lc
	irmovl 1234564789,%ecx
	rmmovl %ecx,lx
	irmovl 2147483647,%edx
	rmmovl %edx,ly
	irmovl 1,%ebx
	rmmovl %ebx,lb
	irmovl -1,%esi
	rmmovl %esi,lc
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl label: sss,%edi
	rmmovl %edi,lnull
	irmovl 1,%ecx
	rmmovl %ecx,lx
L17:
L18:
L19:
L20:
	irmovl 1,%edx
	rmmovl %edx,ly
L22:
L23:
	irmovl #t3 = y 1 1,%edx
	rmmovl %edx,ly
	irmovl #t4 = x 1 1,%ecx
	rmmovl %ecx,lx
	popl edi
	popl esi
	popl ebx
	halt

mult:
	mrmovl 4(%esp), %ecx
	mrmovl 8(%esp), %edx
	xorl %eax, %eax
multbcl:
	andl %edx, %edx
	je multfin
	addl %ecx, %eax
	isubl 1,%edx
	jmp multbcl
multfin: ret
div:
	popl %eax
	popl %eax

	.align 4
la:	.long 0
lb:	.long 0
lnull:	.long 0
lc:	.long 0
lx:	.long 0
ly:	.long 0
stack:
** Enregistre fct:pgcd
* MOVE(CONST:0,NAME(i))
SEQ(Label(L27),SEQ(CJUMP(15,NAME(i),NAME(j),L28,L29),SEQ(Label(L28),SEQ(MOVE(CONST:0,NAME(i)),SEQ(JUMP(NAME(L27),L27),Label(L29))))))
* MOVE(BINOP(-1,NAME(i),NAME(j)),NAME(i))
* MOVE(BINOP(-1,NAME(j),NAME(i)),NAME(j))
** SEQ(Label(L26),SEQ(SEQ(Label(L27),SEQ(CJUMP(15,NAME(i),NAME(j),L28,L29),SEQ(Label(L28),SEQ(MOVE(CONST:0,NAME(i)),SEQ(JUMP(NAME(L27),L27),Label(L29)))))),SEQ(SEQ(CJUMP(12,NAME(i),NAME(i),L30,L31),SEQ(Label(L30),SEQ(MOVE(BINOP(-1,NAME(i),NAME(j)),NAME(i)),SEQ(Label(L31),MOVE(BINOP(-1,NAME(j),NAME(i)),NAME(j)))))),MOVE(EXP(t4),NAME(i)))))
* MOVE(CONST:0,NAME(i))
SEQ(Label(L33),SEQ(CJUMP(15,NAME(i),NAME(j),L34,L35),SEQ(Label(L34),SEQ(MOVE(CONST:0,NAME(i)),SEQ(JUMP(NAME(L33),L33),Label(L35))))))
* MOVE(BINOP(-1,NAME(i),NAME(j)),NAME(i))
* MOVE(BINOP(-1,NAME(j),NAME(i)),NAME(j))
funct; SEQ(Label(L32),SEQ(SEQ(Label(L33),SEQ(CJUMP(15,NAME(i),NAME(j),L34,L35),SEQ(Label(L34),SEQ(MOVE(CONST:0,NAME(i)),SEQ(JUMP(NAME(L33),L33),Label(L35)))))),SEQ(SEQ(CJUMP(12,NAME(i),NAME(i),L36,L37),SEQ(Label(L36),SEQ(MOVE(BINOP(-1,NAME(i),NAME(j)),NAME(i)),SEQ(Label(L37),MOVE(BINOP(-1,NAME(j),NAME(i)),NAME(j)))))),MOVE(EXP(t5),NAME(i)))))
