package ubordeaux.deptinfo.compilation.project.main;

import java.util.Iterator;
import fr.c12.compilator.error.*;
import ubordeaux.deptinfo.compilation.project.type.*;
import fr.c12.compilator.special.*;
import java.util.Scanner;
import java.util.HashMap;
import fr.c12.compilator.environment.*;
import java.util.Stack;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import ubordeaux.deptinfo.compilation.project.intermediateCode.*;
import java.util.Map;
import beaver.*;
import ubordeaux.deptinfo.compilation.project.node.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjM0bu5jKLFREW68jDH311qAWWkmieA2A4dSWI41DP12HimQ01Dv2c8jGgUnH5K703YI0" +
		"YeYYue8AA288BRb1QYcrLj5MnrPRQzdhc$VV$CpF$OaAZt#Vt#USxS#wxxyqzzysRUNCdWB" +
		"iI#SX2FtH68UhWAVm2jN0CVebqPE1OrCPng8lZaOakQ8Dsk13deXTwem$w8XiDS1gQe2RUb" +
		"dsOggqJSGeQeXGte0XNuI8KO10knN1ScI32KV#tzcWur2uDQRkLq1w3F7J01TG#WX5EK3iI" +
		"fnH7naNmPtfqbJBjY2VH0zraAtNgXJAzjXfrJj8vf57dtg2EI4gTuYhfdAmwIsGVbOBpAKs" +
		"fSqMLT4wDhebH2UeqIAapiGewR#5fNCSrUXORgRCMDT18TRjIPtrAdLzLGQUnHYt4CzHf6h" +
		"hV#gVKMPTK9nlD0v7yLoaRzT4CBN0wpaGhd1teknYx0ttPQ8#M6gaxTeNYT4mQPnI6XEACn" +
		"5XqmXc1hA9nXYMDauqHAVh69##J3vBsNSCp$NsN1tgtuVbGvXDmbcOzaFT1C8D9ILMk3rsT" +
		"#9LVYfjGXbin3R$1Rt4pRi4Cj5QboR8Xrd#dhp$gMvJ0Tty2tzO4lZSJ#Dxt#U8p$Tdpq$B" +
		"CmHJv32jXqzfYh8MqLaGjcH7plQRMENhVBPITs8INS1lkmapCmknAMtDmeubLxbDg6utA#s" +
		"mDLkDHdAUUyvLpbATZRiAeyt075k1svEguV0nGliJmOFKFLRvCUPnoYVBLoXkugq#LzxrTF" +
		"JRxnsGz7i5oRC5yF84Td7svxC3TV5VUW$lmQpo0nUY9PPoPjpUim8Du20$ZPLwfLVAnV2H$" +
		"eUznF2TluGMyYCsCymgsurMyWTUn4#$oxnry0E0zphuTPzwUcNJWxf33$R0pLwyhkd5lxK6" +
		"DNAvYBrXSDuUrIWqSmNgZ9giX6sdcdJ#8QvpETq6QhmB8vEvPZtLAVUu#9$9Txxs7uoCqhm" +
		"RjCTJE36bVK2NjTFv5xKYSJEwfuGY7dsaJldLAk5#3EgU7CYsgHftecOEfOuLqy0Fej3PNB" +
		"gYJ#GFef1cLe4vQjUaCvzFPd6iqajL1Ej#AOsEH7EfSMMqw$lFYxxUCmzInGv7yLycELLzr" +
		"JFtbxyjWtURlirc$HIDbiVO8nccIDCx0a8RDkGrclHZCwllpITrtJeg#zAHzwUprzvqTw6t" +
		"12ZAOUPjOrXcy3u8gGvAgj0rTdVYLZxpzybWVzsVDF83LR7vCQHolTgB#7yCNd#dFdf#Qfx" +
		"7nZAPb6IijO4sCMPUeLV5SPl4Rff3V1AVogw0Hln0gQqKrc$cKAg96xxEe9ymP$DPA7BKfl" +
		"sUAavvNLVPszGBk0Dwk7ftzCCvvA67nYMriPj#ChLPi3sNx2kRcVRavvlke9Rq5n1bcZCli" +
		"l3$Fby4$RzvP9gvtDHfho#AUcY72TpomvqOUF8Z80L8kOEUH9tW#$YOInnBhYA#YOwiA$cO" +
		"GhG5hRuNF$fQ7se3ZalkJQv5BoNKvZdhEIUJkv2RadkIpJ7K0fnrv8BaBUJMvDta$EP$Zwf" +
		"27aJaFPonvDvaLZTMFV3tvqmfzQp1zqvc7Bqzh9jlbv2yYRVTIZfbDNt7YUTdJE7Pjn7Rke" +
		"7r0$MLitqEUh7sCQH#ZzXhQ3TNUGBkLddEyNglbHByA3MSJ#t9eS2vsVMhKKlysjlkotKdR" +
		"kzXclZRdPHLep2BjMq$VjMf$p7dLL$iWiPVjHfLPHxqcDObE8H$NpoqXk3wkjwRxDVv7sj#" +
		"7c4hZWE#S8Up$Z7orjcyYPX73j3t7DtOuCTVN7aTSJXHhczVU7S0vhWpbDJJ2bbvxzsRbMu" +
		"X5n4Bcy25vklf74ulLdio#Btsnk9xklSGaWlU9o$l9hUlhNqeiKtiASGAn89YFKyhdx12D5" +
		"imfE#93A$fU9NFTCAyoQv0A$EM6sgkKz#crgAsSfpn5UPfokV9svOCHjdihwpXde$8doZhE" +
		"#Je#9#TGWZox1DjkhShDpyq8jUlux2oVtS1ddnmynzh2GmrY7ksTEgQHvhLP#HlrDzLpccc" +
		"xfVONy5gqZTXslYzszFwjotNTKU6tHrLcVjy$VsTFXMrVeto3$neG3OFds3E2RRVDuMcxEJ" +
		"h7#I7$qUgVaYBlnQ5pkllocny$tgtdwrzIOLltiI$NrrSUF0zx#3Rxd$nNzdaDysIPdsoHb" +
		"#KbsIoRv4LvGPwNZVASh957PRKy8cLcnBDoFu#CBtpEXS#xB27k9kuYk5V8dSG2WlkDt4xC" +
		"9nOJYypvjycj6ka1cITBZVMqEJubSsMEp9PPCbEUvAXdw2kJTQQlJ9um$BWvhZN7nwAPorP" +
		"vJVDVHJoizihOh5R8W$AGiPOHVv3Vg$ztyY$vftmZNyi$vE$obHoKB#KB#W$8v$8tn7xo2V" +
		"5djVya7whrH#M$4djajx4$bVtgtQkyNChb5V9xn3l4Bdax5lTDStpT7BV9TlX#yeQyo#D$v" +
		"5jj7v9$aoQnsZYADI8mni3czvq7hrvn#KLW9KH$7$eG5odwyXolCiXZrUDX0AlHOlgZk9Yn" +
		"ypbcF7cygQrSViE2i5bZUR1OYRbyoXrJOR6Q82n#QTk4nShDDhYCzaXY5FUJKQntHt3S2BO" +
		"BULwXrdGTgEtjxgnQC8Zd3AA$eo8d1JfJlml7dq$s$YypWRuInYiXToLt8xeJFOYUH2Vw$S" +
		"ZbURdKlf3SY$aLSKmH$KFOvXkKS5Y7MeHBUD$eJWXs4ZiHh1ZQ9y1Ltm6an$rp");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};
 
	public HashMap<String,Node> symtab = new HashMap<String,Node> ();	//ref du td6 a completer
	
	//public Stm statement;	//pour utiliser les methodes... a completer
	
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
		System.err.format("*** " + msg + " ligne %d, colonne %d\n",
			Symbol.getLine(token.getStart()),
			Symbol.getColumn(token.getStart()));
		
	}
	
	public void semanticErrorReformated(Symbol token) {
			System.err.format(" ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
	}
		
	private TypeEnvironment typeEnvironment = new TypeEnvironment("types");
	private ProcedureEnvironment procedureEnvironment = new ProcedureEnvironment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;
	
	
	private boolean verbose_mode = true;	
	private boolean critical_mode = true;

	private boolean generate_intermediate_code = true;

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = constant_declaration_part.l1 type_declaration_part.tp variable_declaration_part.vp procedure_definition_part.pp TOKEN_BEGIN push_stackenv.pu statement_list.l TOKEN_END pop_stackenv.pop
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l1 = _symbols[offset + 1];
					final NodeList l1 = (NodeList) _symbol_l1.value;
					final Symbol tp = _symbols[offset + 2];
					final Symbol vp = _symbols[offset + 3];
					final Symbol pp = _symbols[offset + 4];
					final Symbol pu = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final NodeList l = (NodeList) _symbol_l.value;
					final Symbol pop = _symbols[offset + 9];
					 
		if(generate_intermediate_code)
			l1.add(l);
			System.out.println(l1);
			//System.out.println("Intermediate Code Generation:");
			//System.out.println(l1.generateIntermediateCode().toString() + "\n");
			//System.out.println(l1.generateIntermediateCode().toString());
	    return _symbol_l1;
				}
			},
			new Action() {	// [1] constant_declaration_part = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 
									return new NodeList(new NodeAssign(new NodeId("null", new TypePointer()), new NodeLiteral(new TypePointer() , null)));
				}
			},
			Action.NONE,  	// [2] type_declaration_part = 
			RETURN2,	// [3] type_declaration_part = TOKEN_TYPE type_declaration_list; returns 'type_declaration_list' although none is marked
			new Action() {	// [4] type_declaration_list = type_declaration_list type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [5] type_declaration_list = type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [6] type_declaration = TOKEN_IDENTIFIER.name TOKEN_AFF type.t TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					
			try{
				typeEnvironment.putVariable(name, t);
			} catch (RedefinitionType e) {
				if(verbose_mode) {
					e.printStackTrace();
				}
			} finally {
				return new EmptySymbol();
			}
				}
			},
			Action.RETURN,	// [7] type = simple_type
			Action.RETURN,	// [8] type = named_type
			Action.RETURN,	// [9] type = index_type
			Action.RETURN,	// [10] type = array_type
			Action.RETURN,	// [11] type = pointer_type
			Action.RETURN,	// [12] type = structure_type
			new Action() {	// [13] simple_type = TOKEN_STRING
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeString();
				}
			},
			new Action() {	// [14] simple_type = TOKEN_INTEGER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeInt();
				}
			},
			new Action() {	// [15] simple_type = TOKEN_BOOLEAN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeBoolean();
				}
			},
			new Action() {	// [16] named_type = TOKEN_IDENTIFIER.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_r = _symbols[offset + 1];
					final String r = (String) _symbol_r.value;
					 
		//System.out.println("Named: " + r); 
		try {
			return typeEnvironment.getVariableValue(r);
		} catch(UnknownType e) {	//Si pas deja present
			//System.err.println(e);
			return new TypeNamed(r);
		}
				}
			},
			Action.RETURN,	// [17] index_type = enumerated_type
			Action.RETURN,	// [18] index_type = subrange_type
			new Action() {	// [19] enumerated_type = init_enumerated_type TOKEN_LPAR identifier_list.id_l TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id_l = _symbols[offset + 3];
					final IdentifierList id_l = (IdentifierList) _symbol_id_l.value;
					 
			Vector<Type> array_tmp = new Vector<>();
			int const_id = 0;
			for(String identifier : id_l) {
				array_tmp.add(new TypeItemEnum(const_id, identifier));
				const_id +=1;
			}
			return new TypeTuple(array_tmp);
				}
			},
			Action.NONE,  	// [20] init_enumerated_type = 
			new Action() {	// [21] subrange_type = TOKEN_LIT_INTEGER.min TOKEN_DOTDOT TOKEN_LIT_INTEGER.max
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_min = _symbols[offset + 1];
					final Integer min = (Integer) _symbol_min.value;
					final Symbol _symbol_max = _symbols[offset + 3];
					final Integer max = (Integer) _symbol_max.value;
					 	
			if(min > max) {
				InvalidType e = new InvalidType("@subrange_type] min@" + min + " is greater than max@" +max);
				if(verbose_mode) {
					e.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);
			}
			return new TypeArrayRange(new TypeInt(min), new TypeInt(max));
				}
			},
			new Action() {	// [22] subrange_type = TOKEN_IDENTIFIER.id_min TOKEN_DOTDOT TOKEN_IDENTIFIER.id_max
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id_min = _symbols[offset + 1];
					final String id_min = (String) _symbol_id_min.value;
					final Symbol _symbol_id_max = _symbols[offset + 3];
					final String id_max = (String) _symbol_id_max.value;
						
			try {
				int val_min = typeEnvironment.getEnumType(id_min).getValue();
				int val_max = typeEnvironment.getEnumType(id_max).getValue();

				if(val_min > val_max) {
					InvalidType e = new InvalidType("@subrange_type] min@[" + id_min + ":" + val_min + "] is greater than max@[" + id_max + ":" +val_max +"]");
					if(verbose_mode) {
						e.printStackTrace();
					}
					if(critical_mode)
						System.exit(0);
				}

				return new TypeArrayRange(new TypeInt(val_min), new TypeInt(val_max));
				
			} catch (UnknownEnumType e) {
				if(verbose_mode) {
					e.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);
				System.err.println("[InvalidAffectation] Automatically recover from error." );
				return new TypeArrayRange(new TypeInt(0), new TypeInt(0));
			}
				}
			},
			new Action() {	// [23] array_type = TOKEN_ARRAY TOKEN_LBRACKET range_type.range TOKEN_RBRACKET TOKEN_OF type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_range = _symbols[offset + 3];
					final Type range = (Type) _symbol_range.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final Type t = (Type) _symbol_t.value;
					 return new TypeArray(range, t);
				}
			},
			Action.RETURN,	// [24] range_type = enumerated_type
			Action.RETURN,	// [25] range_type = subrange_type
			Action.RETURN,	// [26] range_type = named_type
			new Action() {	// [27] pointer_type = TOKEN_CIRC type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					 return new TypePointer(t);
				}
			},
			new Action() {	// [28] structure_type = TOKEN_STRUCT TOKEN_LBRACE feature_list_type.list TOKEN_RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 3];
					final TypeFeatureList list = (TypeFeatureList) _symbol_list.value;
					 return new TypeStruct(list);
				}
			},
			new Action() {	// [29] feature_list_type = feature_list_type.list feature_type.elem
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final TypeFeatureList list = (TypeFeatureList) _symbol_list.value;
					final Symbol _symbol_elem = _symbols[offset + 2];
					final TypeFeature elem = (TypeFeature) _symbol_elem.value;
					 list.add(elem); return list;
				}
			},
			new Action() {	// [30] feature_list_type = feature_type.elem
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_elem = _symbols[offset + 1];
					final TypeFeature elem = (TypeFeature) _symbol_elem.value;
					 TypeFeatureList list = new TypeFeatureList(elem); return list;
				}
			},
			new Action() {	// [31] feature_type = TOKEN_IDENTIFIER.id TOKEN_COLON type.t TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new TypeFeature(id, t);
				}
			},
			Action.NONE,  	// [32] variable_declaration_part = 
			RETURN2,	// [33] variable_declaration_part = TOKEN_VAR variable_declaration_list; returns 'variable_declaration_list' although none is marked
			new Action() {	// [34] variable_declaration_list = variable_declaration_list variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [35] variable_declaration_list = variable_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [36] variable_declaration = identifier_list.id_list TOKEN_COLON type.t TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id_list = _symbols[offset + 1];
					final IdentifierList id_list = (IdentifierList) _symbol_id_list.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					
																for(String str : id_list){
																	try {
																		stackEnvironment.add_type_to_latest_portability(str, t);
																	}catch ( RedefinitionVariable e) {
																		if(verbose_mode) {
																			e.printStackTrace();
																		}
																		if(critical_mode)
																			System.exit(0);
																	}
																}
																
																return _symbol_id_list;
				}
			},
			new Action() {	// [37] identifier_list = identifier_list.list TOKEN_COMMA TOKEN_IDENTIFIER.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					 
																	list.add(id); return list;
				}
			},
			new Action() {	// [38] identifier_list = TOKEN_IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 
																	return new IdentifierList(name);
				}
			},
			Action.NONE,  	// [39] procedure_definition_part = 
			Action.RETURN,	// [40] procedure_definition_part = procedure_definition_list
			new Action() {	// [41] procedure_definition_list = procedure_definition_list procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [42] procedure_definition_list = procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [43] procedure_definition = procedure_definition_head.type_fct block.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type_fct = _symbols[offset + 1];
					final TypeFunct type_fct = (TypeFunct) _symbol_type_fct.value;
					final Symbol _symbol_stm = _symbols[offset + 2];
					final NodeList stm = (NodeList) _symbol_stm.value;
						

		if(generate_intermediate_code) {
			System.out.println(new Label(new LabelLocation()));
			stm.generateIntermediateCode();
		}
		stackEnvironment.getEnvironment().pop();
		return stm;
				}
			},
			RETURN2,	// [44] procedure_definition = procedure_declaration_head TOKEN_SEMIC; returns 'TOKEN_SEMIC' although none is marked
			new Action() {	// [45] procedure_definition_head = procedure_head.type_fct
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type_fct = _symbols[offset + 1];
					final TypeFunct type_fct = (TypeFunct) _symbol_type_fct.value;
					
		try {
			type_fct.setDefined(true); 
			procedureEnvironment.putVariable(type_fct.getName(), type_fct); 
		} catch (RedefinitionFunction|RedefinitionFunctionPrototype e) {
			//System.err.println(e + " at Line : " + Symbol.getLine(type_fct.getStart()));
			if(verbose_mode) {
				e.printStackTrace();
			}
			if(critical_mode)
				System.exit(0);
		}
		return type_fct;
				}
			},
			new Action() {	// [46] procedure_declaration_head = procedure_head.type_fct
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type_fct = _symbols[offset + 1];
					final TypeFunct type_fct = (TypeFunct) _symbol_type_fct.value;
					
			stackEnvironment.getEnvironment().pop();
			try {
				type_fct.setDefined(false); 
				procedureEnvironment.putVariable(type_fct.getName(), type_fct); 
			} catch (RedefinitionFunction|RedefinitionFunctionPrototype e) {
				System.err.println(e + " at Line : " + Symbol.getLine(type_fct.getStart()));
				if(verbose_mode) {
					e.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);
			}
			return type_fct;
				}
			},
			new Action() {	// [47] procedure_head = TOKEN_PROCEDURE TOKEN_IDENTIFIER.funct_name TOKEN_LPAR argt_part.args TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_funct_name = _symbols[offset + 2];
					final String funct_name = (String) _symbol_funct_name.value;
					final Symbol _symbol_args = _symbols[offset + 4];
					final NodeList args = (NodeList) _symbol_args.value;
									
				TypeTuple params_tuple = new TypeTuple();	
				stackEnvironment.getEnvironment().push(new HashMap<String, Type>()); 			

				for(Node n : args.getList()) {
					try {
						NodeId n_id = (NodeId) n;
						params_tuple.add(new TypeFeature(n_id.getName(), n_id.getType()));
						stackEnvironment.add_type_to_latest_portability(n_id.getName(), n_id.getType());
				
					}catch ( RedefinitionVariable e) {
						System.err.println(e + " at Line : " + Symbol.getLine(args.getStart()));
						if(verbose_mode) {
							e.printStackTrace();
						}
						if(critical_mode)
							System.exit(0);
					}
				}
				
				
				TypeFunct type_function = new TypeFunct(funct_name, params_tuple, new TypeVoid());
				return type_function;
				}
			},
			new Action() {	// [48] procedure_head = TOKEN_FUNCTION TOKEN_IDENTIFIER.funct_name TOKEN_LPAR argt_part.args TOKEN_RPAR TOKEN_COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_funct_name = _symbols[offset + 2];
					final String funct_name = (String) _symbol_funct_name.value;
					final Symbol _symbol_args = _symbols[offset + 4];
					final NodeList args = (NodeList) _symbol_args.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final Type t = (Type) _symbol_t.value;
					
				TypeTuple params_tuple = new TypeTuple();
				stackEnvironment.getEnvironment().push(new HashMap<String, Type>()); 
				
				for(Node n : args.getList()) {
					try {
						NodeId n_id = (NodeId) n;
						params_tuple.add(new TypeFeature(n_id.getName(), n_id.getType()));
						stackEnvironment.add_type_to_latest_portability(n_id.getName(), n_id.getType());

					}catch ( RedefinitionVariable e) {
						//System.err.println(e + " at Line : " + Symbol.getLine(args.getStart()));
						if(verbose_mode) {
							e.printStackTrace();
						}
						if(critical_mode)
							System.exit(0);
					}
				}
				
				TypeFunct type_function = new TypeFunct(funct_name, params_tuple, t);

				//stackEnvironment.getEnvironment().pop(); 
				return type_function;
				//return new NodeCallFct(funct_name, type_function, new NodeList());
				}
			},
			Action.NONE,  	// [49] argt_part = 
			Action.RETURN,	// [50] argt_part = argt_list
			new Action() {	// [51] argt_list = argt_list.nl TOKEN_COMMA argt.elem
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_nl = _symbols[offset + 1];
					final NodeList nl = (NodeList) _symbol_nl.value;
					final Symbol _symbol_elem = _symbols[offset + 3];
					final NodeId elem = (NodeId) _symbol_elem.value;
					 nl.add(elem); return nl;
				}
			},
			new Action() {	// [52] argt_list = argt.elem
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_elem = _symbols[offset + 1];
					final NodeId elem = (NodeId) _symbol_elem.value;
					 NodeList nl = new NodeList(elem); return nl;
				}
			},
			new Action() {	// [53] argt = TOKEN_IDENTIFIER.id TOKEN_COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new NodeId(id, t);
				}
			},
			new Action() {	// [54] block = variable_declaration_part TOKEN_BEGIN push_stackenv statement_list.list TOKEN_END pop_stackenv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 4];
					final NodeList list = (NodeList) _symbol_list.value;
					 return _symbol_list;
				}
			},
			new Action() {	// [55] pop_stackenv = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
						
						//System.out.println("[STACK] Poped one more stack layer"); 
						stackEnvironment.getEnvironment().pop(); 
						return new EmptySymbol();
				}
			},
			new Action() {	// [56] push_stackenv = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
						
						//System.out.println("[STACK] Pushed one more stack layer"); 
						stackEnvironment.getEnvironment().push(new HashMap<String, Type>(stackEnvironment.getEnvironment().peek())); 
						return new EmptySymbol();
				}
			},
			new Action() {	// [57] statement_list = statement_list.root statement.elt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_root = _symbols[offset + 1];
					final NodeList root = (NodeList) _symbol_root.value;
					final Symbol _symbol_elt = _symbols[offset + 2];
					final Node elt = (Node) _symbol_elt.value;
					 root.add(elt); return root;
				}
			},
			new Action() {	// [58] statement_list = statement.elt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_elt = _symbols[offset + 1];
					final Node elt = (Node) _symbol_elt.value;
					 return new NodeList(elt);
				}
			},
			Action.RETURN,	// [59] statement = simple_statement
			Action.RETURN,	// [60] statement = structured_statement
			Action.RETURN,	// [61] simple_statement = assignment_statement
			Action.RETURN,	// [62] simple_statement = procedure_statement
			Action.RETURN,	// [63] simple_statement = new_statement
			Action.RETURN,	// [64] simple_statement = dispose_statement
			Action.RETURN,	// [65] simple_statement = println_statement
			Action.RETURN,	// [66] simple_statement = readln_statement
			Action.RETURN,	// [67] simple_statement = return_statement
			new Action() {	// [68] assignment_statement = variable_access.e1 TOKEN_AFF expression.e2 TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					  
		//System.out.println("ASSIGN;::::" + e1.getType() + " -> " + e2.getType());
			
			//Type(e1) = Type(e2), ou Pointer(Type(e1)) = Type(e2) 
			if(!e1.getType().equals(e2.getType()) && !(new TypePointer(e1.getType()).equals(e2.getType()) )) {
				InvalidAffectation e = new InvalidAffectation("Impossible to assign a " + e1.getType() + " to " + e2.getType() + " at line: " + Symbol.getColumn(e1.getStart()));
				if(verbose_mode) {
					e.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);
				System.err.println("[InvalidAffectation] Automatically recover from error." );
				return new NodeAssign(e1,e1);
			}
			return new NodeAssign(e1, e2);
				}
			},
			new Action() {	// [69] procedure_statement = procedure_expression.n TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final NodeCallFct n = (NodeCallFct) _symbol_n.value;
					 return n;
				}
			},
			new Action() {	// [70] procedure_expression = TOKEN_IDENTIFIER.func_name TOKEN_LPAR expression_part.args TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func_name = _symbols[offset + 1];
					final String func_name = (String) _symbol_func_name.value;
					final Symbol _symbol_args = _symbols[offset + 3];
					final NodeList args = (NodeList) _symbol_args.value;
					 
																				try{
																					stackEnvironment.getEnvironment().push(new HashMap<String, Type>()); //push env
																					HashMap<String, Type> table = (HashMap<String, Type>) stackEnvironment.getEnvironment().peek();
																					
																					TypeFunct fct_type = procedureEnvironment.getTypeFct(func_name);
																					Iterator<Type> it = fct_type.getParams().iterator();
																					while(it.hasNext()) {
																						try {
																							TypeFeature type_feature= (TypeFeature) it.next();
																							stackEnvironment.add_type_to_latest_portability(type_feature.getName(), type_feature.getType());	
																						} catch (RedefinitionVariable e) {
																							if(verbose_mode) {
																								e.printStackTrace();
																							}
																							System.err.println(e);
																						}
																					}
																					return new NodeCallFct(func_name, fct_type, args);
																				
																				}catch(UnknownProcedure e){
																					System.err.println("[UnknownProcedure] line: " + Symbol.getColumn(args.getStart()));
																					/*if(verbose_mode) {
																						e.printStackTrace();
																					}*/
																					if(verbose_mode) {
																						e.printStackTrace();
																					}
																					//System.out.println("Procedure Expression: " + e + " at Line : " + Symbol.getLine(args.getStart()));
																					return new NodeCallFct(func_name, new TypeFunct(func_name, new TypeTuple(), new TypeVoid()), args);
																				}
				}
			},
			Action.NONE,  	// [71] expression_part = 
			Action.RETURN,	// [72] expression_part = expression_list
			new Action() {	// [73] expression_list = expression_list.root TOKEN_COMMA expression.elt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_root = _symbols[offset + 1];
					final NodeList root = (NodeList) _symbol_root.value;
					final Symbol _symbol_elt = _symbols[offset + 3];
					final NodeExp elt = (NodeExp) _symbol_elt.value;
					 root.add(elt); return root;
				}
			},
			new Action() {	// [74] expression_list = expression.expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_expr = _symbols[offset + 1];
					final NodeExp expr = (NodeExp) _symbol_expr.value;
					 return new NodeList(expr);
				}
			},
			new Action() {	// [75] new_statement = TOKEN_NEW variable_access.node TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_node = _symbols[offset + 2];
					final NodeExp node = (NodeExp) _symbol_node.value;
					 
		if(!(node.getType() instanceof TypePointer)) {
			InvalidPointerAccess e = new InvalidPointerAccess("Trying to new a variable that is not a pointer." + " at line: " + Symbol.getColumn(node.getStart()));
			if(verbose_mode) {
				e.printStackTrace();
			}
			if(critical_mode)
				System.exit(0);
			return node;
		}
		return new NodeNew(node);
				}
			},
			new Action() {	// [76] dispose_statement = TOKEN_DISPOSE variable_access.node TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_node = _symbols[offset + 2];
					final NodeExp node = (NodeExp) _symbol_node.value;
					 
								if(!(node.getType() instanceof TypePointer)) {
									InvalidPointerAccess e = new InvalidPointerAccess("Trying to dispose a variable that is not a pointer." + " at line: " + Symbol.getColumn(node.getStart()));
									if(verbose_mode) {
										e.printStackTrace();
									}
									if(critical_mode)
										System.exit(0);
									return node;
								}

								return new NodeDispose(node);
				}
			},
			new Action() {	// [77] println_statement = TOKEN_PRINTLN expression.args TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_args = _symbols[offset + 2];
					final NodeExp args = (NodeExp) _symbol_args.value;
					 
				TypeTuple params_tuple = null;

				if(args instanceof NodeCallFct) {
					NodeCallFct tmp = (NodeCallFct) args;
					params_tuple= new TypeTuple(new TypeFeature(tmp.getName(), tmp.getType()));
				} else {
					params_tuple= new TypeTuple(new TypeFeature("println nodelist", args.getType()));
				}

				
				return new NodeCallFct(
						"println",
						new TypeFunct("println", params_tuple, new TypeVoid()),
						new NodeList(args));
				}
			},
			new Action() {	// [78] readln_statement = TOKEN_READLN expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
			return new NodeCallFct(
				"readln", 
				new TypeFunct("readln", 
					new TypeTuple(e.getType()), 
					e.getType()),
				new NodeList());
				}
			},
			new Action() {	// [79] return_statement = TOKEN_RETURN expression.node TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_node = _symbols[offset + 2];
					final NodeExp node = (NodeExp) _symbol_node.value;
					 return new NodeReturn(node);
				}
			},
			Action.RETURN,	// [80] structured_statement = block
			Action.RETURN,	// [81] structured_statement = if_statement
			Action.RETURN,	// [82] structured_statement = while_statement
			Action.RETURN,	// [83] structured_statement = switch_statement
			new Action() {	// [84] if_statement = TOKEN_IF expression.e TOKEN_THEN statement.stm_if
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm_if = _symbols[offset + 4];
					final Node stm_if = (Node) _symbol_stm_if.value;
						
			return new NodeIf(e, new NodeList(stm_if));
				}
			},
			new Action() {	// [85] if_statement = TOKEN_IF expression.e TOKEN_THEN statement.stm_if TOKEN_ELSE statement.stm_else
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm_if = _symbols[offset + 4];
					final Node stm_if = (Node) _symbol_stm_if.value;
					final Symbol _symbol_stm_else = _symbols[offset + 6];
					final Node stm_else = (Node) _symbol_stm_else.value;
					 
			return new NodeIf(e, new NodeList(stm_if), new NodeList(stm_else));
				}
			},
			new Action() {	// [86] while_statement = TOKEN_WHILE expression.e1 TOKEN_DO statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 2];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
						return new NodeWhile(e1, new NodeList(stm));
				}
			},
			new Action() {	// [87] switch_statement = TOKEN_SWITCH expression.root TOKEN_BEGIN case_statement_list.case_list TOKEN_END
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_root = _symbols[offset + 2];
					final NodeExp root = (NodeExp) _symbol_root.value;
					final Symbol _symbol_case_list = _symbols[offset + 4];
					final NodeCaseList case_list = (NodeCaseList) _symbol_case_list.value;
					  System.out.println("Size is : " + case_list.size());
																							return new NodeSwitch(root, case_list);
				}
			},
			new Action() {	// [88] case_statement_list = case_statement_list.list case_statement.case_arr case_default.case_default
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeCaseList list = (NodeCaseList) _symbol_list.value;
					final Symbol _symbol_case_arr = _symbols[offset + 2];
					final NodeList case_arr = (NodeList) _symbol_case_arr.value;
					final Symbol _symbol_case_default = _symbols[offset + 3];
					final NodeCase case_default = (NodeCase) _symbol_case_default.value;
					
				Iterator<Node> it = case_arr.iterator();
				while(it.hasNext()) {
					NodeCase nc = (NodeCase) it.next();
					list.add(nc);
				}

				if(case_default instanceof NodeCase) {
					list.add(case_default);
				}
				return list;
				}
			},
			new Action() {	// [89] case_statement_list = case_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 1];
					final NodeList stm = (NodeList) _symbol_stm.value;
					 
				NodeCaseList list = new NodeCaseList();
				
				Iterator<Node> it = stm.iterator();
				while(it.hasNext()) {
					NodeCase nc = (NodeCase) it.next();
					list.add(nc);
				}
				return list;
				}
			},
			new Action() {	// [90] case_statement = TOKEN_CASE identifier_list.id_list TOKEN_COLON statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id_list = _symbols[offset + 2];
					final IdentifierList id_list = (IdentifierList) _symbol_id_list.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 
			NodeList res = new NodeList();
			for(String case_name : id_list) {
				res.add(new NodeCase(case_name, new NodeList(stm)));
			}
			return res;
				}
			},
			Action.NONE,  	// [91] case_default = 
			new Action() {	// [92] case_default = TOKEN_DEFAULT TOKEN_COLON statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 3];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeCase(null, new NodeList(stm));
				}
			},
			new Action() {	// [93] variable_access = TOKEN_IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
						
			try{
				Type t = stackEnvironment.get_type_reachable(name);  
				return new NodeId(name, t);
			} catch (UnknownVariable e) {	//Not a normal variable
				try {						//Check enum
					Type tmp = typeEnvironment.getEnumType(name);
					if(tmp instanceof TypeItemEnum) {
						TypeItemEnum t = (TypeItemEnum) tmp;
						return new NodeId(t.getRefEnumRange(), new TypeInt(t.getValue()));
					}
					return new NodeId(null, null);					
					
				} catch (UnknownEnumType e2) {
					if(verbose_mode) {
						e2.printStackTrace();
					}

					if(critical_mode)
						System.exit(0);
					return new NodeId(null, null);
				}
			}
				}
			},
			new Action() {	// [94] variable_access = variable_access.var TOKEN_LBRACKET expression.e TOKEN_RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_var = _symbols[offset + 1];
					final NodeExp var = (NodeExp) _symbol_var.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					
			if(!(var.getType() instanceof TypeArray) ) {
				System.err.println("[InvalidArrayAccess] Trying to access a variable as array@" + var.getType() + "with " +e);
				if(critical_mode)
					System.exit(0);
				System.err.println("[InvalidArrayAccess] Automatically recover from syntax error.");
				return var;
				
			}
			if(e.getType() instanceof TypeBoolean || e.getType() instanceof TypeString) {
				System.err.println("[InvalidArrayAccess] Invalid Type@" + e.getType() + " to access array.");
				if(critical_mode)
					System.exit(0);
				System.err.println("[InvalidArrayAccess] Automatically recover from syntax error.");
				return var;
				//return new NodeArrayAccess(var, new NodeLiteral(new TypeInt(0), 0));
			}
			return new NodeArrayAccess(var, e);
				}
			},
			new Action() {	// [95] variable_access = expression.e TOKEN_CIRC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
		/*
		if(!(e.getType() instanceof TypePointer)){
			System.err.println("[MEMLEAK] Trying to access free or undeclared pointer");
			
			if(critical_mode)
				System.exit(0);
			return e;
		}
		*/
		return new NodePtrAccess(e);
				}
			},
			new Action() {	// [96] expression = expression.e1 TOKEN_PLUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 

			//Gerer cas pointeur aussi
			if(!(e1.getType() instanceof TypeInt) || !(e2.getType() instanceof TypeInt)) {
				InvalidBinOperation e = new InvalidBinOperation("Arithmetic: left@"+e1.getType() + ", right@"+e2.getType() + " at line: " + Symbol.getColumn(e2.getStart()));
				if(verbose_mode) {
					e.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);

				System.err.println("[InvalidBinOperation] Automatically recover from error." );
				return new NodeOp("invalid expr", e1, e2);
			}
			return new NodeOp("plus", e1, e2);
				}
			},
			new Action() {	// [97] expression = expression.e1 TOKEN_MINUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
			//Gerer cas pointeur aussi
			if(!(e1.getType() instanceof TypeInt) || !(e2.getType() instanceof TypeInt)) {
				InvalidBinOperation e = new InvalidBinOperation("Arithmetic: left@"+e1.getType() + ", right@"+e2.getType() + " at line: " + Symbol.getColumn(e2.getStart()));
				if(verbose_mode) {
					e.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);

				System.err.println("[InvalidBinOperation] Automatically recover from error." );
				return new NodeOp("invalid expr", e1, e2);
			}
			return new NodeOp("minus", e1, e2);
				}
			},
			new Action() {	// [98] expression = expression.e1 TOKEN_TIMES expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
			//Gerer cas pointeur aussi
			if(!(e1.getType() instanceof TypeInt) || !(e2.getType() instanceof TypeInt)) {
				InvalidBinOperation e = new InvalidBinOperation("Arithmetic: left@"+e1.getType() + ", right@"+e2.getType() + " at line: " + Symbol.getColumn(e2.getStart()));
				if(verbose_mode) {
					e.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);

				System.err.println("[InvalidBinOperation] Automatically recover from error." );
				return new NodeOp("invalid expr", e1, e2);
			}
			return new NodeOp("times", e1, e2);
				}
			},
			new Action() {	// [99] expression = expression.e1 TOKEN_DIV expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 
			if(!(e1.getType() instanceof TypeInt) || !(e2.getType() instanceof TypeInt)) {
				InvalidBinOperation e = new InvalidBinOperation("Arithmetic: left@"+e1.getType() + ", right@"+e2.getType() + " at line: " + Symbol.getColumn(e2.getStart()));
				if(verbose_mode) {
					e.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);

				System.err.println("[InvalidBinOperation] Automatically recover from error." );
				return new NodeOp("invalid expr", e1, e2);
			}
			return new NodeOp("divide", e1, e2);
				}
			},
			new Action() {	// [100] expression = TOKEN_MINUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 
			if(!(e.getType() instanceof TypeInt)) {
				InvalidBinOperation err = new InvalidBinOperation("Arithmetic: UnaryMinus:@"+e.getType() + " at line: " + Symbol.getColumn(e.getStart()));
				if(verbose_mode) {
					err.printStackTrace();
				}
				if(critical_mode)
					System.exit(0);

				System.err.println("[InvalidBinOperation] Automatically recover from error." );
				return new NodeOp("invalid expr", e);
			}
			return new NodeOp("u_minus", e);
				}
			},
			new Action() {	// [101] expression = expression.e1 TOKEN_OR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("or", e1, e2);
				}
			},
			new Action() {	// [102] expression = expression.e1 TOKEN_AND expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("an", e1, e2);
				}
			},
			new Action() {	// [103] expression = TOKEN_NOT expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeRel("no", e, new NodeLiteral(new TypeBoolean(), false));
				}
			},
			new Action() {	// [104] expression = expression.e1 TOKEN_LT expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("lt", e1, e2);
				}
			},
			new Action() {	// [105] expression = expression.e1 TOKEN_LE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("le", e1, e2);
				}
			},
			new Action() {	// [106] expression = expression.e1 TOKEN_GT expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("gt", e1, e2);
				}
			},
			new Action() {	// [107] expression = expression.e1 TOKEN_GE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("ge", e1, e2);
				}
			},
			new Action() {	// [108] expression = expression.e1 TOKEN_EQ expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("eq", e1, e2);
				}
			},
			new Action() {	// [109] expression = expression.e1 TOKEN_NE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("ne", e1, e2);
				}
			},
			new Action() {	// [110] expression = TOKEN_LPAR expression.e TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return e;
				}
			},
			Action.RETURN,	// [111] expression = procedure_expression
			Action.RETURN,	// [112] expression = variable_access
			Action.RETURN,	// [113] expression = literal
			new Action() {	// [114] literal = TOKEN_LIT_INTEGER.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_value = _symbols[offset + 1];
					final Integer value = (Integer) _symbol_value.value;
					 return new NodeLiteral(new TypeInt(), value);
				}
			},
			new Action() {	// [115] literal = TOKEN_LIT_STRING.value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_value = _symbols[offset + 1];
					final String value = (String) _symbol_value.value;
					 return new NodeLiteral(new TypeString(), value);
				}
			},
			new Action() {	// [116] literal = TOKEN_TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), true);
				}
			},
			new Action() {	// [117] literal = TOKEN_FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), false);
				}
			},
			new Action() {	// [118] literal = TOKEN_NULL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeVoid(), null);
				}
			}
		};

 
	report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
